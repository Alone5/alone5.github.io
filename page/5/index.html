<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Wt Blog">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Wt Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wt Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>Wt Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wt Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/30/Java-Date/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/30/Java-Date/" itemprop="url">Java-Date(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-30T13:52:06+08:00">
                2019-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-日期时间"><a href="#Java-日期时间" class="headerlink" title="Java 日期时间"></a>Java 日期时间</h2><h3 id="Java日期涉及几大类"><a href="#Java日期涉及几大类" class="headerlink" title="Java日期涉及几大类"></a>Java日期涉及几大类</h3><h4 id="1-java-util-Date"><a href="#1-java-util-Date" class="headerlink" title="1. java.util.Date"></a>1. java.util.Date</h4><ul>
<li>Date类负责时间的表示，在计算机中，时间的表示是一个较大的概念，现有的系统基本都是利用从1970.1.1 00:00:00 到当前时间的毫秒数进行计时，这个时间称为epoch。在后文中如果没有明确说明，毫秒数就是指从1970年到对应时间的毫秒数。在Java 的Date类内部其实也是一个毫秒数，对外表现为一个Date对象。<h5 id="Date类方法"><a href="#Date类方法" class="headerlink" title="Date类方法"></a>Date类方法</h5></li>
<li><strong>Date()</strong><ul>
<li>分配一个 Date对象，并初始化它，以便它代表它被分配的时间，测量到最近的毫秒。</li>
</ul>
</li>
<li><strong>Date(long date)</strong><ul>
<li>分配一个 Date对象，并将其初始化为表示自称为“时代”的标准基准时间以后的指定毫秒数，即1970年1月1日00:00:00 GMT。</li>
</ul>
</li>
<li><strong>void  setTime(long date)</strong><ul>
<li>使用给定的毫秒时间值设置现有的 Date对象。</li>
</ul>
</li>
<li><strong>void  setTime(long time)</strong><ul>
<li>设置此 Date对象以表示1970年1月1日00:00:00 GMT后的 time毫秒的时间点。</li>
</ul>
</li>
<li><strong>Instant  toInstant()</strong><ul>
<li>此方法总是引发UnsupportedOperationException，因为SQL Date值没有时间组件，所以不应该使用。</li>
</ul>
</li>
<li><strong>LocalDate  toLocalDate()</strong><ul>
<li>将此 Date对象转换为 LocalDate</li>
</ul>
</li>
<li><strong>String  toString()</strong><ul>
<li>格式化日期转义格式yyyy-mm-dd。</li>
</ul>
</li>
<li><strong>static Date  valueOf(LocalDate date)</strong><ul>
<li>从一个LocalDate对象获取一个Date的实例，具有与给定的LocalDate相同的年，月和日的月值。</li>
</ul>
</li>
<li><strong>static Date  valueOf(String s)</strong><ul>
<li>将JDBC日期转义格式的字符串转换为 Date值。</li>
</ul>
</li>
<li><strong>boolean    after(Date when)</strong><ul>
<li>测试此日期是否在指定日期之后。</li>
</ul>
</li>
<li><strong>boolean    before(Date when)</strong><ul>
<li>测试此日期是否在指定日期之前。</li>
</ul>
</li>
<li><strong>Object    clone()</strong><ul>
<li>返回此对象的副本。</li>
</ul>
</li>
<li><strong>int    compareTo(Date anotherDate)</strong><ul>
<li>比较两个日期进行订购。</li>
</ul>
</li>
<li><strong>boolean    equals(Object obj)</strong><ul>
<li>比较两个日期来平等。</li>
</ul>
</li>
<li><strong>static Date    from(Instant instant)</strong><ul>
<li>从 Instant对象获取一个 Date的实例。</li>
</ul>
</li>
<li><strong>long    getTime()</strong><ul>
<li>返回自1970年1月1日以来，由此 Date对象表示的00:00:00 GMT的毫秒 数 。</li>
</ul>
</li>
<li><strong>int    hashCode()</strong><ul>
<li>返回此对象的哈希码值。</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用几个方法使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//当前系统时间</span></span><br><span class="line">	Date date = <span class="keyword">new</span> Date();</span><br><span class="line">	System.out.println(date);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 获取Date内部维护的毫秒</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">long</span> time = date.getTime();</span><br><span class="line">	System.out.println(time);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 设置一个毫秒值，使得Date表示该日期</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	date.setTime(<span class="number">10</span>);</span><br><span class="line">	System.out.println(date);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Date大部分方法被声明为过时的，新开发项目不要再使用这些方法。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	date.getYear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-java-util-Calendar（抽象类）"><a href="#2-java-util-Calendar（抽象类）" class="headerlink" title="2.java.util.Calendar（抽象类）"></a>2.java.util.Calendar（抽象类）</h4><ul>
<li>Calendar类说是一个工具类，其实它比工具类还是更深一步的，它更像是一个加强版的Date类。一般的工具类会提供一堆static方法，工具类本身并不存储对象。但是Calendar类不是像一般的工具类只提供一堆static方法，而是在其内部本身就有一个毫秒数，所以它不是对外部Date对象操作，而是对内部的毫秒数进行转化，所以说Calendar本身就包含了日期时间信息，像一个装饰者模式。</li>
<li>Calendar本身是一个抽象类，不能直接实例化，但是Calendar类提供一个工厂方法，即getInstance来创建一个Calendar实例，通过setTime()设定一个Calendar内部的毫秒数，之后就可以对这个毫秒数进行分析，进而得到它的年月日信息。同时，我们也可以对Calendar直接设定年月日属性，从而获取对应的Date对象。</li>
<li>GregorianCalendar 是 Calendar 的一个具体子类，提供了世界上大多数国家使用的标准日历系统。结合Calendar抽象类使用。</li>
</ul>
<h5 id="Calendar类对象字段类型"><a href="#Calendar类对象字段类型" class="headerlink" title="Calendar类对象字段类型"></a>Calendar类对象字段类型</h5><table>
<thead>
<tr>
<th style="text-align:left">常量</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Calendar.YEAR</td>
<td style="text-align:left">年份</td>
</tr>
<tr>
<td style="text-align:left">Calendar.MONTH</td>
<td style="text-align:left">月份</td>
</tr>
<tr>
<td style="text-align:left">Calendar.DATE</td>
<td style="text-align:left">日期</td>
</tr>
<tr>
<td style="text-align:left">Calendar.DAY_OF_MONTH</td>
<td style="text-align:left">日期，和上面的字段意义完全相同</td>
</tr>
<tr>
<td style="text-align:left">Calendar.HOUR</td>
<td style="text-align:left">12小时制的小时</td>
</tr>
<tr>
<td style="text-align:left">Calendar.HOUR_OF_DAY</td>
<td style="text-align:left">24小时制的小时</td>
</tr>
<tr>
<td style="text-align:left">Calendar.MINUTE</td>
<td style="text-align:left">分钟</td>
</tr>
<tr>
<td style="text-align:left">Calendar.SECOND</td>
<td style="text-align:left">秒</td>
</tr>
<tr>
<td style="text-align:left">Calendar.DAY_OF_WEEK</td>
<td style="text-align:left">星期几</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>Calendar中需要注意的：</strong></li>
</ul>
<ol>
<li>Calendar的星期是从周日开始的，常量值为0。</li>
<li>Calendar的月份是从一月开始的，常量值为0。</li>
<li>Calendar的每个月的第一天值为1。</li>
</ol>
<ul>
<li><strong>常用方法示例:</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * static Calendar getInstance()</span></span><br><span class="line"><span class="comment">	 * 根据当前系统所在地区获取一个适用的实现类</span></span><br><span class="line"><span class="comment">	 * 通常返回的就是GregorianCalendar</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Calendar calendar = Calendar.getInstance();</span><br><span class="line">	System.out.println(calendar);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Date getTime()</span></span><br><span class="line"><span class="comment">	 * 将当前Calendar的表示的时间一个Date实例形式返回。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Date date = calendar.getTime();</span><br><span class="line">	System.out.println(date);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * void setTime()</span></span><br><span class="line"><span class="comment">	 * 调整当前calendar的时间为给定的Date所表示的时间。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	calendar.setTime(date);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * int get(int field)</span></span><br><span class="line"><span class="comment"> * 该方法可以获取指定的时间分量所对应的值。</span></span><br><span class="line"><span class="comment"> * 时间分量为一个int值，无需记住每个值得含义，</span></span><br><span class="line"><span class="comment"> * Calendar提供了大量的常量与之对应。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1：获取年</span></span><br><span class="line"><span class="comment">		 * 2：获取月</span></span><br><span class="line"><span class="comment">		 * 3：获取日</span></span><br><span class="line"><span class="comment">		 * 与"天"相关的时间分量</span></span><br><span class="line"><span class="comment">		 * DAY_OF_MONTH：月中的天(DATE)</span></span><br><span class="line"><span class="comment">		 * DAY_OF_WEEK：周中的天,星期几</span></span><br><span class="line"><span class="comment">		 * DAY_OF_YEAR：年中的天</span></span><br><span class="line"><span class="comment">		 * HOUR	12小时制的小时</span></span><br><span class="line"><span class="comment">		 * HOUR_OF_DAY	24小时制的小时</span></span><br><span class="line"><span class="comment">		 * MINUTE	分钟</span></span><br><span class="line"><span class="comment">		 * SECOND	秒</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">		<span class="keyword">int</span> month = c.get(Calendar.MONTH);</span><br><span class="line">		<span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">		<span class="keyword">int</span> h = c.get(Calendar.HOUR_OF_DAY);</span><br><span class="line">		<span class="keyword">int</span> m = c.get(Calendar.MINUTE);</span><br><span class="line">		<span class="keyword">int</span> s = c.get(Calendar.SECOND);</span><br><span class="line">		System.out.println(year + <span class="string">"-"</span> + month + <span class="string">"-"</span> + day);</span><br><span class="line">		System.out.println(h + <span class="string">":"</span> + m + <span class="string">":"</span> + s);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">int</span> days = c.get(Calendar.DAY_OF_YEAR);</span><br><span class="line">		System.out.println(<span class="string">"今年的第"</span> + days + <span class="string">"天"</span>);</span><br><span class="line">		days = c.get(Calendar.DAY_OF_WEEK);</span><br><span class="line">		String[] data = &#123; <span class="string">"日"</span>, <span class="string">"一"</span>, <span class="string">"二"</span>, <span class="string">"三"</span>, <span class="string">"四"</span>, <span class="string">"五"</span>, <span class="string">"六"</span> &#125;;</span><br><span class="line">		System.out.println(<span class="string">"今天是周"</span> + data[days - <span class="number">1</span>]);</span><br><span class="line">		<span class="comment">// 获取指定时间分量所允许的最大值</span></span><br><span class="line">		days = c.getActualMaximum(Calendar.DAY_OF_YEAR);</span><br><span class="line">		System.out.println(<span class="string">"今年一共"</span> + days + <span class="string">"天"</span>);</span><br><span class="line">		days = c.getActualMaximum(Calendar.DAY_OF_MONTH);</span><br><span class="line">		System.out.println(<span class="string">"当月一共"</span> + days + <span class="string">"天"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void set(int field , int value)</span></span><br><span class="line"><span class="comment"> * 调整指定的时间分量为指定的值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo3</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调整年</span></span><br><span class="line">		c.set(Calendar.YEAR, <span class="number">2000</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">		<span class="comment">// 调整月</span></span><br><span class="line">		c.set(Calendar.MONTH, Calendar.DECEMBER);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line"></span><br><span class="line">		c.set(Calendar.HOUR_OF_DAY, <span class="number">20</span>);</span><br><span class="line">		c.set(Calendar.MINUTE, <span class="number">20</span>);</span><br><span class="line">		c.set(Calendar.SECOND, <span class="number">20</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line"></span><br><span class="line">		c.set(Calendar.DAY_OF_WEEK, <span class="number">4</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> date;</span><br><span class="line"><span class="keyword">import</span> java.util.Calendar;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * void add(int field,int amount) </span></span><br><span class="line"><span class="comment"> * 对指定的时间分量加上给定的值，若给定的值为负数则是减去。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Calendar c = Calendar.getInstance();</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 查看三年二月零25天以后所在周的周三是哪天？</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//加年</span></span><br><span class="line">		c.add(Calendar.YEAR, <span class="number">3</span>);</span><br><span class="line">		<span class="comment">//加月</span></span><br><span class="line">		c.add(Calendar.MONTH, <span class="number">2</span>);</span><br><span class="line">		<span class="comment">//加天</span></span><br><span class="line">		c.add(Calendar.DAY_OF_YEAR, <span class="number">25</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">		c.set(Calendar.DAY_OF_WEEK, <span class="number">4</span>);</span><br><span class="line">		System.out.println(c.getTime());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/29/Java-Lambda/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/29/Java-Lambda/" itemprop="url">Java-Lambda</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-29T19:22:42+08:00">
                2019-05-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><ul>
<li>Java 8的一个大亮点是引入Lambda表达式，使用它设计的代码会更加简洁。当开发者在编写Lambda表达式时，也会随之被编译成一个函数式接口。</li>
<li>使用Lambda表达式不仅让代码变的简单、而且可读、最重要的是代码量也随之减少很多。</li>
<li><p><strong>语法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(参数列表)-&gt;&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>lambda表达式的重要特征:</strong></p>
<ul>
<li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li>
<li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li>
<li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li>
<li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</li>
</ul>
</li>
<li><p>没有使用Lambda的老方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable runnable1=<span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"Hello!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用Lambda:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Runnable r2 = () -&gt; &#123;</span><br><span class="line">	System.out.println(<span class="string">"Hi!"</span>);</span><br><span class="line">	&#125;;</span><br><span class="line"><span class="comment">// 只有一句代码 &#123;&#125;可以省略</span></span><br><span class="line">Runnable r3 = () -&gt; System.out.println(<span class="string">"Hi!"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>方法中含有参数:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">		list.add(<span class="string">"one"</span>);</span><br><span class="line">		list.add(<span class="string">"three"</span>);</span><br><span class="line">		list.add(<span class="string">"four"</span>);</span><br><span class="line">		</span><br><span class="line">		Collections.sort(list,<span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">return</span> o2.length()-o1.length();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 参数类型无需指定，编译器会根据程序长下文分析出参数类型，</span></span><br><span class="line"><span class="comment">		 * 若不能确定时需要指定(否则编译不通过)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Collections.sort(list,(o1,o2)-&gt;&#123;</span><br><span class="line">			<span class="keyword">return</span> o1.length()-o2.length();</span><br><span class="line">		&#125;);</span><br><span class="line">		System.out.println(list);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果可以忽略&#123;&#125; 那么方法中的return关键字也要省略</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Collections.sort(list,(o1,o2)-&gt;o1.length()-o2.length());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/Java-reflect/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/Java-reflect/" itemprop="url">Java-reflect</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T18:57:50+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Java-反射"><a href="#Java-反射" class="headerlink" title="Java 反射"></a>Java 反射</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><ul>
<li>反射 (Reflection) 是 Java 的特征之一，它允许运行中的 Java 程序获取自身的信息，并且可以操作类或对象的内部属性。</li>
<li>简而言之，通过反射，我们可以在运行时获得程序或程序集中每一个类型的成员和成员的信息。程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</li>
<li>反射的核心是 JVM 在运行时才动态加载类或调用方法/访问属性，它不需要事先（写代码的时候或编译期）知道运行对象是谁。</li>
<li><p>Java 反射主要提供以下功能：</p>
<ul>
<li>在运行时判断任意一个对象所属的类；</li>
<li>在运行时构造任意一个类的对象；</li>
<li>在运行时判断任意一个类所具有的成员变量和方法（通过反射甚至可以调用private方法）；</li>
<li>在运行时调用任意一个对象的方法<br>重点：是运行时而不是编译时</li>
</ul>
</li>
<li><p><strong>注意事项：</strong></p>
</li>
<li>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。</li>
<li>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</li>
</ul>
<h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><ul>
<li>类对象，它的每一个实例用于表示JVM加载的一个类。并且在JVM内部，每个被加载的类有且只有一个类对象。通过类对象可以得知其表示的类的一切信息(类名，有哪些方法，属性，构造器等)，并且可以快速实例化该类的实例。</li>
</ul>
<h4 id="Class-forName-动态加载类"><a href="#Class-forName-动态加载类" class="headerlink" title="Class.forName() 动态加载类"></a>Class.forName() 动态加载类</h4><ul>
<li>动态加载类到内存方法区：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class cls = Class.forName(类名)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>类名是运行期间动态输入的类名，可以任何类名。</li>
<li>返回值是一个引用，利用这个引用指向的对象可以访问方法区中的类信息。</li>
<li>如果类名是错的将会出现”类没有找到”异常，(ClassNotFoundException)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);   </span><br><span class="line">		System.out.println(<span class="string">"请输入要加载的类名："</span>);</span><br><span class="line">		String className = scan.nextLine();</span><br><span class="line"><span class="comment">//		Class cls = Class.forName(className);</span></span><br><span class="line">		Class cls = String.class;</span><br><span class="line">		String name = cls.getName();</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="newInstance-动态创建对象"><a href="#newInstance-动态创建对象" class="headerlink" title="newInstance() 动态创建对象"></a>newInstance() 动态创建对象</h4><ul>
<li>Class提供了动态创建对象的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">newInstance</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>newInstance方法将调用类信息中的无参数构造器创建对象，如果没有无参数构造器，将抛出没有方法的异常。</li>
<li>如果需要调用有参数构造器，可以利用Constructor API实现。</li>
<li>返回值引用动态创建的对象，因为可以是任何类型的对象，所以其类型为Object。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入要实例化的类名："</span>);</span><br><span class="line">		String className = scan.nextLine();</span><br><span class="line">		Class cls = Class.forName(className);</span><br><span class="line">		Object o = cls.newInstance();</span><br><span class="line">		System.out.println(o);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="动态调用方法"><a href="#动态调用方法" class="headerlink" title="动态调用方法"></a>动态调用方法</h3><h4 id="动态发现方法"><a href="#动态发现方法" class="headerlink" title="动态发现方法"></a>动态发现方法</h4><ul>
<li>Class提供了方法可以动态获取类的全部方法信息：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Method[] getMethods()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>Method代表方法信息，可以利用Method API获取方法对详细信息，如：方法名，返回值类型列表等。</li>
<li>这个方法返回对数组代表当前类中对全部方法信息，每个元素代表一个方法信息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo1</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);   </span><br><span class="line">		System.out.println(<span class="string">"请输入要加载的类名："</span>);</span><br><span class="line">		String className = scan.nextLine();</span><br><span class="line"><span class="comment">//		Class cls = Class.forName(className);</span></span><br><span class="line">		Class cls = String.class;</span><br><span class="line">		String name = cls.getName();</span><br><span class="line">		System.out.println(name);</span><br><span class="line">		<span class="comment">//Method类的每一个实例用于表示一个具体的方法</span></span><br><span class="line">		Method[] methods = cls.getMethods();</span><br><span class="line">		<span class="keyword">for</span>(Method m : methods) &#123;</span><br><span class="line">			System.out.println(m.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="动态执行方法"><a href="#动态执行方法" class="headerlink" title="动态执行方法"></a>动态执行方法</h4><ul>
<li>Method提供了动态执行一个方法的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(obj, args)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>obj代表一个对象，该对象上一定包含当前方法！否则将会出现调用异常，如果obj为null则抛出空指针异常。</li>
<li>args代表调用方法时候传递的实际参数，如果没有参数可以不用或者传递null，但是要注意参数的个数和类型必须和要调用的方法匹配，否则会出现参数错误异常。</li>
<li>返回值表示方法执行的结果，因为可能是任何类型，则其类型为Object，调用没有返回值的方法则返回值为null；</li>
<li>当被调用方法执行出现异常时候抛出InvocationTargetException。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo4</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 1:加载类对象</span></span><br><span class="line"><span class="comment">		 * 2：获取对应方法</span></span><br><span class="line"><span class="comment">		 * 3：执行该方法</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Class cls = Class.forName(<span class="string">"reflect.Person"</span>);</span><br><span class="line">		Object o = cls.newInstance();</span><br><span class="line"><span class="comment">//		Method m = cls.getMethod("sayHello");</span></span><br><span class="line"><span class="comment">//		m.invoke(o);</span></span><br><span class="line">		</span><br><span class="line">		Method me = cls.getMethod(<span class="string">"say"</span>, String.class);</span><br><span class="line">		me.invoke(o, <span class="string">"wangtao"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="执行不可访问方法"><a href="#执行不可访问方法" class="headerlink" title="执行不可访问方法"></a>执行不可访问方法</h4><ul>
<li>如果利用反射API调用了没有可访问权限时候会抛出异常：IllegalAccessException，表示没有访问权限。</li>
<li><p>但是在Method方法上提供了解除访问限制的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setAccessible(<span class="keyword">boolean</span> flag)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在invoke之前使用这个方法可以解除访问限制，实现访问没有权限的方法。</p>
</li>
<li>注意：这个功能破坏了面向对象原有的封装性，但是利用它却能写出一些特殊功能代码。</li>
</ul>
<h3 id="变长参数"><a href="#变长参数" class="headerlink" title="变长参数"></a>变长参数</h3><ul>
<li>在Java5 中提供了变长参数（varargs），也就是在方法定义中可以使用个数不确定的参数，对于同一方法可以使用不同个数的参数调用。</li>
<li>演示案例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo5</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		dosome();</span><br><span class="line">		dosome(<span class="string">"one"</span>,<span class="string">"two"</span>);</span><br><span class="line">		dosome(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>);</span><br><span class="line">		dosome(<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>,<span class="string">"one"</span>,<span class="string">"two"</span>,<span class="string">"three"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 变长参数在一个方法中只能定义一个，</span></span><br><span class="line"><span class="comment">	 * 并且只能作为方法的最后一个参数使用。</span></span><br><span class="line"><span class="comment">	 * 变长参数本质就是一个数组。</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> s</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dosome</span><span class="params">(String... s)</span> </span>&#123;</span><br><span class="line">		System.out.println(s.length);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/27/Java-Map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/27/Java-Map/" itemprop="url">Java-Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-27T18:52:01+08:00">
                2019-05-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h2><ul>
<li><strong>Map接口中键和值一一映射. 可以通过键来获取值。</strong><ul>
<li><strong>给定一个键和一个值，你可以将该值存储在一个Map对象. 之后，你可以通过键来访问对应的值。</strong></li>
<li><strong>当访问的值不存在的时候，方法就会抛出一个NoSuchElementException异常.</strong></li>
<li><strong>当对象的类型和Map里元素类型不兼容的时候，就会抛出一个 ClassCastException异常。</strong></li>
<li><strong>当在不允许使用Null对象的Map中使用Null对象，会抛出一个NullPointerException 异常。</strong></li>
<li><strong>当尝试修改一个只读的Map时，会抛出一个UnsupportedOperationException异常。</strong></li>
</ul>
</li>
</ul>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul>
<li><strong>void    clear()</strong><ul>
<li><strong>从该地图中删除所有的映射（可选操作）。</strong></li>
</ul>
</li>
<li><strong>default V    compute(K key, BiFunction&lt; ? super K,? super V,? extends V&gt; remappingFunction)</strong><ul>
<li><strong>尝试计算指定键的映射及其当前映射的值（如果没有当前映射， null ）。</strong></li>
</ul>
</li>
<li><strong>default V    computeIfAbsent(K key, Function&lt; ? super K,? extends V&gt; mappingFunction)</strong><ul>
<li><strong>如果指定的键尚未与值相关联（或映射到 null ），则尝试使用给定的映射函数计算其值，并将其输入到此映射中，除非 null 。</strong></li>
</ul>
</li>
<li><strong>default V    computeIfPresent(K key, BiFunction&lt; ? super K,? super V,? extends V&gt; remappingFunction)</strong><ul>
<li><strong>如果指定的密钥的值存在且非空，则尝试计算给定密钥及其当前映射值的新映射。</strong></li>
</ul>
</li>
<li><strong>boolean    containsKey(Object key)</strong><ul>
<li><strong>如果此映射包含指定键的映射，则返回 true 。</strong></li>
</ul>
</li>
<li><strong>boolean    containsValue(Object value)</strong><ul>
<li><strong>如果此地图将一个或多个键映射到指定的值，则返回 true 。</strong></li>
</ul>
</li>
<li><strong>Set&lt;Map.Entry&lt;K,V&gt;&gt;    entrySet()</strong><ul>
<li><strong>返回此地图中包含的映射的Set视图。</strong></li>
</ul>
</li>
<li><strong>boolean    equals(Object o)</strong><ul>
<li><strong>将指定的对象与此映射进行比较以获得相等性。</strong></li>
</ul>
</li>
<li><strong>default void    forEach(BiConsumer&lt; ? super K,? super V&gt; action)</strong><ul>
<li><strong>对此映射中的每个条目执行给定的操作，直到所有条目都被处理或操作引发异常。</strong></li>
</ul>
</li>
<li><strong>V    get(Object key)</strong><ul>
<li><strong>返回到指定键所映射的值，或 null如果此映射包含该键的映射。</strong></li>
</ul>
</li>
<li><strong>default V    getOrDefault(Object key, V defaultValue)</strong><ul>
<li><strong>返回到指定键所映射的值，或 defaultValue如果此映射包含该键的映射。</strong></li>
</ul>
</li>
<li><strong>int    hashCode()</strong><ul>
<li><strong>返回此地图的哈希码值。</strong></li>
</ul>
</li>
<li><strong>boolean    isEmpty()</strong><ul>
<li><strong>如果此地图不包含键值映射，则返回 true 。</strong></li>
</ul>
</li>
<li><strong>Set&lt; K &gt;    keySet()</strong><ul>
<li><strong>返回此地图中包含的键的Set视图。</strong></li>
</ul>
</li>
<li><strong>default V    merge(K key, V value, BiFunction&lt; ? super V,? super V,? extends V&gt; remappingFunction)</strong><ul>
<li><strong>如果指定的键尚未与值相关联或与null相关联，则将其与给定的非空值相关联。</strong></li>
</ul>
</li>
<li><strong>V    put(K key, V value)</strong><ul>
<li><strong>将指定的值与该映射中的指定键相关联（可选操作）。</strong></li>
</ul>
</li>
<li><strong>void    putAll(Map&lt; ? extends K,? extends V&gt; m)</strong><ul>
<li><strong>将指定地图的所有映射复制到此映射（可选操作）。</strong></li>
</ul>
</li>
<li><strong>default V    putIfAbsent(K key, V value)</strong><ul>
<li><strong>如果指定的键尚未与某个值相关联（或映射到 null ）将其与给定值相关联并返回 null ，否则返回当前值。</strong></li>
</ul>
</li>
<li><strong>V    remove(Object key)</strong><ul>
<li><strong>如果存在（从可选的操作），从该地图中删除一个键的映射。</strong></li>
</ul>
</li>
<li><strong>default boolean    remove(Object key, Object value)</strong><ul>
<li><strong>仅当指定的密钥当前映射到指定的值时删除该条目。</strong></li>
</ul>
</li>
<li><strong>default V    replace(K key, V value)</strong><ul>
<li><strong>只有当目标映射到某个值时，才能替换指定键的条目。</strong></li>
</ul>
</li>
<li><strong>default boolean    replace(K key, V oldValue, V newValue)</strong><ul>
<li><strong>仅当当前映射到指定的值时，才能替换指定键的条目。</strong></li>
</ul>
</li>
<li><strong>default void    replaceAll(BiFunction&lt; ? super K,? super V,? extends V&gt; function)</strong><ul>
<li><strong>将每个条目的值替换为对该条目调用给定函数的结果，直到所有条目都被处理或该函数抛出异常。</strong></li>
</ul>
</li>
<li><strong>int    size()</strong><ul>
<li><strong>返回此地图中键值映射的数量。</strong></li>
</ul>
</li>
<li><strong>Collection&lt; V &gt;    values()</strong><ul>
<li><strong>返回此地图中包含的值的Collection视图。</strong></li>
</ul>
</li>
</ul>
<h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><ul>
<li><strong>hashMap是一个用于存储key-value键值对的集合，每一个键值对也被叫做Entry。这些个键值对分散存储在一个数组当中，这个数组就是HaspMap的主干。</strong></li>
<li><strong>总体上看，Hashmap分为很多个数组，每一个数组里面存放着一个链表。</strong></li>
</ul>
<h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><ul>
<li><strong>key的hashCode()方法的返回值对HashMap存储元素时起着很重要的作用。而hashCode()方法实际上是在Object中定义的。那么应当妥善重写该方法：</strong><ul>
<li><strong>对于重写equals方法的对象，一般要妥善的重写继承自Object类的hashCode方法，Object提供的hashCode方法将返回该对象所在内存地址的整数形式。</strong></li>
<li><strong>重写hashCode方法时需注意两点：</strong><ul>
<li><strong>1：与equals方法的一致性，即equals比较返回true的两个对象其hashCode方法返回值应该相同。</strong></li>
<li><strong>2：hashCode返回的数值应符合hash算法的要求，如果有很多对象的hashCode方法返回值都相同，则会大大降低hash表的效率。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>Capacity：容量，hash表里bucket(桶)的数量，也就是散列数组大小。</strong></li>
<li><strong>Initial capacity：初始容量，创建hash表示，初始bucket的数量，默认构建容量是16，也可以使用特定容量。</strong></li>
<li><strong>Size：大小，当前散列表中储存数据的数量。</strong></li>
<li><strong>Load factor：加载因子，默认值0.75(75%)，当向散列表增加数据时如果size/capacity的值大于Load factor则发生扩充并且重新散列(rehash)。</strong></li>
<li><strong>性能优化：加载银子较小时，散列查找性能会提高，同时也浪费了散列桶空间容量。0.75是性能和空间相对平衡结果。在创建散列表时指定合理容量，减少rehash提高性能。</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/25/Java-XML/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/25/Java-XML/" itemprop="url">Java-XML</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-25T10:44:37+08:00">
                2019-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul>
<li><strong>可扩展标记语言（英语：Extensible Markup Language，简称：XML），是一种标记语言。标记指计算机所能理解的信息符号，通过此种标记，计算机之间可以处理包含各种信息的文章等。如何定义这些标记，既可以选择国际通用的标记语言，比如HTML，也可以使用像XML这样由相关人士自由决定的标记语言，这就是语言的可扩展性。XML是从标准通用标记语言（SGML）中简化修改出来的。它主要用到的有可扩展标记语言、可扩展样式语言（XSL）、XBRL和XPath等。</strong></li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p><strong>XML设计用来传送及携带数据信息，不用来表现或展示数据，HTML则用来表现数据，所以XML用途的焦点是它说明数据是什么，以及携带数据信息。</strong></p>
<ul>
<li><strong>丰富文件（Rich Documents）- 自定文件描述并使其更丰富</strong><ul>
<li><strong>属于文件为主的XML技术应用</strong></li>
<li><strong>标记是用来定义一份资料应该如何呈现</strong></li>
</ul>
</li>
<li><strong>元数据（Metadata）- 描述其它文件或网络资讯</strong><ul>
<li><strong>属于资料为主的XML技术应用</strong></li>
<li><strong>标记是用来说明一份资料的意义</strong></li>
</ul>
</li>
<li><strong>配置文档（Configuration Files）- 描述软件设置的参数</strong></li>
</ul>
<h3 id="处理节点"><a href="#处理节点" class="headerlink" title="处理节点"></a>处理节点</h3><p>xml 推荐在第一行，必须写在第一行，可以省略。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="标记（标签）-tag"><a href="#标记（标签）-tag" class="headerlink" title="标记（标签） tag"></a>标记（标签） tag</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">开始标记 &lt;标记名&gt;  </span><br><span class="line">结束标记    &lt;/标记名&gt;</span><br></pre></td></tr></table></figure></p>
<p>标记规则：</p>
<ol>
<li>中文英文都可以作为标记名，建议使用英文</li>
<li>区分大小写</li>
<li>开始标记和结束标记要成对使用</li>
<li>不能交叉嵌套</li>
<li>一个XML中只有唯一的根标记<br>标记名可以扩展 标记的嵌套关系可以扩展</li>
</ol>
<h3 id="注释-Comment"><a href="#注释-Comment" class="headerlink" title="注释 Comment"></a>注释 Comment</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 注释 --&gt;</span><br></pre></td></tr></table></figure></p>
<p>注释不能嵌套使用！！</p>
<h3 id="内容-Content"><a href="#内容-Content" class="headerlink" title="内容 Content"></a>内容 Content</h3><p>语法： 开始标记和结束标记之间的信息称为内容。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;name&gt;檀香刑&lt;/name&gt;</span><br><span class="line">&lt;book&gt;&lt;name&gt;檀香刑&lt;/name&gt;&lt;/book&gt;</span><br><span class="line">&lt;book&gt;</span><br><span class="line">    &lt;name&gt;檀香刑&lt;/name&gt;</span><br><span class="line">    &lt;author&gt;莫言&lt;/author&gt;</span><br><span class="line">&lt;/book&gt;</span><br></pre></td></tr></table></figure></p>
<p>内容：</p>
<ol>
<li>文本内容</li>
<li>标记</li>
<li>多个标记和文本的混合</li>
<li>内容是可扩展的！</li>
</ol>
<h3 id="元素-Element"><a href="#元素-Element" class="headerlink" title="元素 Element"></a>元素 Element</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标记 + 内容 = 元素</span><br></pre></td></tr></table></figure></p>
<ol>
<li>XML 只有一个根元素</li>
<li>元素中的元素称为子元素，外层元素称为父元素</li>
</ol>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>语法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;book id=&quot;b1&quot; lang=&quot;cn&quot;&gt;</span><br><span class="line">&lt;book lang=&quot;cn&quot; id=&quot;b1&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>在开始标记上定义元素的属性</li>
<li>可以定义多个属性</li>
<li>多个属性不分先后次序</li>
<li>属性之间需要有空格</li>
<li>属性名=”属性值” 属性和值之间等号前后不用写空格，属性值必须用 引号</li>
</ol>
<h3 id="实体-Entity"><a href="#实体-Entity" class="headerlink" title="实体 Entity"></a>实体 Entity</h3><p>实体： 类似于 Java 的字符串中的转义字符，一些用于替换表示XML语法的字符。 用来解决XML文字解析错误<br>常用实体：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt; &amp;lt;</span><br><span class="line">&gt; &amp;gt;</span><br><span class="line">&amp; &amp;amp;</span><br></pre></td></tr></table></figure></p>
<h3 id="CDATA"><a href="#CDATA" class="headerlink" title="CDATA"></a>CDATA</h3><p>使用CDATA包裹的文本，可以写任何字符，无需进行实体替换<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;![CDATA[ 文本内容 ]]&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="XML可扩展性"><a href="#XML可扩展性" class="headerlink" title="XML可扩展性"></a>XML可扩展性</h3><ol>
<li>元素（标记）名可以扩展</li>
<li>元素的嵌套关系可以扩展</li>
<li>元素的属性可以扩展</li>
<li>属性名可以扩展</li>
<li>内容可以扩展</li>
</ol>
<h3 id="在Java中使用XML"><a href="#在Java中使用XML" class="headerlink" title="在Java中使用XML"></a>在Java中使用XML</h3><p>Java 业界有API可以读取XML文件。读取以后可以按照元素、属性进行结构分解。<br>Dom4J 读作 Dom for J<br>Dom4J 的底层<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IO 流 -&gt; W3C Dom -&gt; Dom4J</span><br></pre></td></tr></table></figure></p>
<h3 id="利用Maven导入dom4j-API"><a href="#利用Maven导入dom4j-API" class="headerlink" title="利用Maven导入dom4j API"></a>利用Maven导入dom4j API</h3><p>得到Dom4j 的maven组件坐标<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.dom4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;dom4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<p>将组件坐标添加到 pom.xml 文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;cn.tedu&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;XML01&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.dom4j&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;dom4j&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Dom4j-API-的使用"><a href="#Dom4j-API-的使用" class="headerlink" title="Dom4j API 的使用"></a>Dom4j API 的使用</h2><h3 id="读取XML"><a href="#读取XML" class="headerlink" title="读取XML"></a>读取XML</h3><p>Dom4j提供了API将XML文件读取为Dom对象（Document）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 使用dom4j读取xml文件</span><br><span class="line"> */</span><br><span class="line">SAXReader reader = new SAXReader();</span><br><span class="line"></span><br><span class="line">//doc=reader.read(文件、文件流)</span><br><span class="line">Document doc=</span><br><span class="line">  reader.read(new File(&quot;books.xml&quot;));</span><br><span class="line"></span><br><span class="line">System.out.println(doc.asXML());</span><br></pre></td></tr></table></figure></p>
<h3 id="利用Dom-API（Document）可以访问Dom树中的数据"><a href="#利用Dom-API（Document）可以访问Dom树中的数据" class="headerlink" title="利用Dom API（Document）可以访问Dom树中的数据"></a>利用Dom API（Document）可以访问Dom树中的数据</h3><ol>
<li><p>访问根元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//读取根元素, Root 根， Element元素</span><br><span class="line">Element root = doc.getRootElement();</span><br><span class="line">//输出根元素root中的内容</span><br><span class="line">System.out.println(&quot;根元素：&quot;);</span><br><span class="line">System.out.println(root.asXML());</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以获取元素中全部的子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; list=root.elements();</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以获取一批名字一样的子元素</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Element&gt; list= root.elements(&quot;book&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取一个指定名字的子元素, 适合元素的子元素名字都不同，获取其中的一个子元素时候使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Element e = book.element(&quot;name&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取元素中文字内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = name.getText()</span><br><span class="line">String s2 = name.getTextTrim() //去除前后空白，常用！</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取元素的属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;book id=&quot;b1&quot; &gt;</span><br><span class="line">String s = book.attributeValue(&quot;id&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接获取子元素的文本内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String name = book.elementTextTrim(&quot;name&quot;);</span><br></pre></td></tr></table></figure></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/22/Java-Collection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/22/Java-Collection/" itemprop="url">Java-Collection</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-22T16:24:16+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java-集合框架"><a href="#Java-集合框架" class="headerlink" title="Java 集合框架"></a>Java 集合框架</h3><img src="/2019/05/22/Java-Collection/Collection.gif" title="集合框架图">
<ul>
<li><strong>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、HashMap、LinkedHashMap 等等。</strong></li>
<li><strong>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</strong><ul>
<li><strong>接口：是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</strong></li>
<li><strong>实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap。</strong></li>
<li><strong>算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</strong><br><strong>集合与数组一样，都是用来保存一组数据的，但是集合提供了操作元素的相关方法，使用更方便，并且集合有多种不同的数据结构实现。</strong></li>
</ul>
</li>
</ul>
<h3 id="Java集合和数组的区别："><a href="#Java集合和数组的区别：" class="headerlink" title="Java集合和数组的区别："></a>Java集合和数组的区别：</h3><ul>
<li><strong>数组长度在初始化时指定，意味着只能保存定长的数据。而集合可以保存数量不确定的数据。同时可以保存具有映射关系的数据（即关联数组，键值对 key-value）。</strong></li>
<li><strong>数组元素即可以是基本类型的值，也可以是对象。集合里只能保存对象（实际上只是保存对象的引用变量），基本数据类型的变量要转换成对应的包装类才能放入集合类中。</strong></li>
</ul>
<h3 id="集合接口"><a href="#集合接口" class="headerlink" title="集合接口"></a>集合接口</h3><ul>
<li><p><strong>Collection 接口</strong><br><strong>Collection 是最基本的集合接口，一个 Collection 代表一组 Object，即 Collection 的元素, Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。</strong><br><strong>Collection 接口存储一组不唯一，无序的对象。</strong></p>
</li>
<li><p><strong>List 接口</strong><br><strong>List接口是一个有序的 Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的下标)来访问List中的元素，第一个元素的索引为 0，而且允许有相同的元素。</strong><br><strong>List 接口存储一组不唯一，有序（插入顺序）的对象。</strong></p>
</li>
<li><p><strong>Set</strong><br><strong>Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。</strong><br><strong>Set 接口存储一组唯一，无序的对象。</strong></p>
</li>
<li><p><strong>SortedSet</strong><br><strong>继承于Set保存有序的集合。</strong></p>
</li>
<li><p><strong>Map</strong><br><strong>Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</strong></p>
</li>
<li><p><strong>Map.Entry</strong><br><strong>描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</strong></p>
</li>
<li><p><strong>SortedMap</strong><br><strong>继承于 Map，使 Key 保持在升序排列。</strong></p>
</li>
<li><p><strong>Enumeration</strong><br><strong>这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。</strong></p>
</li>
<li><strong>Set和List的区别：</strong><ul>
<li><strong>Set 接口实例存储的是无序的，不重复的数据。List 接口实例存储的是有序的，可以重复的元素。</strong></li>
<li><strong>Set检索效率低下，删除和插入效率高，插入和删除不会引起元素位置改变 &lt;实现类有HashSet,TreeSet&gt;。</strong></li>
<li><strong>List和数组类似，可以动态增长，根据实际存储的数据的长度自动增长List的长度。查找元素效率高，插入删除效率低，因为会引起其他元素位置改变 &lt;实现类有ArrayList,LinkedList,Vector&gt; 。</strong></li>
</ul>
</li>
</ul>
<h3 id="集合实现类（集合类）"><a href="#集合实现类（集合类）" class="headerlink" title="集合实现类（集合类）"></a>集合实现类（集合类）</h3><ul>
<li><strong>Java提供了一套实现了Collection接口的标准集合类。其中一些是具体类，这些类可以直接拿来使用，而另外一些是抽象类，提供了接口的部分实现。</strong></li>
<li><strong>AbstractCollection</strong><br><strong>实现了大部分的集合接口。</strong></li>
<li><strong>AbstractList</strong><br><strong>继承于AbstractCollection 并且实现了大部分List接口。</strong></li>
<li><strong>AbstractSequentialList</strong><br><strong>继承于 AbstractList ，提供了对数据元素的链式访问而不是随机访问。</strong></li>
<li><p><strong>LinkedList</strong><br><strong>该类实现了List接口，允许有null（空）元素。主要用于创建链表数据结构，该类没有同步方法，如果多个线程同时访问一个List，则必须自己实现访问同步，解决方法就是在创建List时候构造一个同步的List。例如：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Listlist=Collections.synchronizedList(newLinkedList(...));</span><br><span class="line">LinkedList 查找效率低。</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>ArrayList</strong><br><strong>该类也是实现了List的接口，实现了可变大小的数组，随机访问和遍历元素时，提供更好的性能。该类也是非同步的,在多线程的情况下不要使用。ArrayList 增长当前长度的50%，插入删除效率低。</strong></p>
</li>
<li><strong>AbstractSet</strong><br><strong>继承于AbstractCollection 并且实现了大部分Set接口。</strong></li>
<li><strong>HashSet</strong><br><strong>该类实现了Set接口，不允许出现重复元素，不保证集合中元素的顺序，允许包含值为null的元素，但最多只能一个。</strong></li>
<li><strong>LinkedHashSet</strong><br><strong>具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。</strong></li>
<li><strong>TreeSet</strong><br><strong>该类实现了Set接口，可以实现排序等功能。</strong></li>
<li><strong>AbstractMap</strong><br><strong>实现了大部分的Map接口。</strong></li>
<li><strong>HashMap</strong><br><strong>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。</strong><br><strong>该类实现了Map接口，根据键的HashCode值存储数据，具有很快的访问速度，最多允许一条记录的键为null，不支持线程同步。</strong></li>
<li><strong>TreeMap</strong><br><strong>继承了AbstractMap，并且使用一颗树。</strong></li>
<li><strong>WeakHashMap</strong><br><strong>继承AbstractMap类，使用弱密钥的哈希表。</strong></li>
<li><strong>LinkedHashMap</strong><br><strong>继承于HashMap，使用元素的自然顺序对元素进行排序.</strong></li>
<li><strong>IdentityHashMap</strong><br><strong>继承AbstractMap类，比较文档时使用引用相等。</strong></li>
</ul>
<h4 id="java-util包中定义的类"><a href="#java-util包中定义的类" class="headerlink" title="java.util包中定义的类:"></a>java.util包中定义的类:</h4><ul>
<li><strong>Vector</strong><br><strong>该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。</strong></li>
<li><strong>Stack</strong><br><strong>栈是Vector的一个子类，它实现了一个标准的后进先出的栈。</strong></li>
<li><strong>Dictionary</strong><br><strong>Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。</strong></li>
<li><strong>Hashtable</strong><br><strong>Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。</strong></li>
<li><strong>Properties</strong><br><strong>Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。</strong></li>
<li><strong>BitSet</strong><br><strong>一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。</strong></li>
</ul>
<h3 id="如何使用迭代器"><a href="#如何使用迭代器" class="headerlink" title="如何使用迭代器"></a>如何使用迭代器</h3><ul>
<li><strong>通常情况下，你会希望遍历一个集合中的元素。例如，显示集合中的每个元素。<br>一般遍历数组都是采用for循环或者增强for，这两个方法也可以用在集合框架，但是还有一种方法是采用迭代器遍历集合框架，它是一个对象，实现了Iterator 接口或ListIterator接口。<br>迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。</strong></li>
</ul>
<h3 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h3><ul>
<li><strong>Iterator iterator()</strong><br><strong>该方法可以获取一个用于遍历当前集合的迭代器实现类通过Iterator就可以遍历集合元素。</strong></li>
<li><strong>java.util.Iterator接口</strong><br><strong>该接口规定了所有迭代器实现类遍历和的通用操作想法 而遍历集合遵循的步骤为：问，取，删，其中删除元素不是必要操作。 不同的集合是提供了一个Iterator的实现类，我们无需记住这些实现类的名字，以Iterator接口接收并调用方法遍历即可。</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		 Collection c = new ArrayList();</span><br><span class="line">		 c.add(<span class="string">"one"</span>);</span><br><span class="line">		 c.add(<span class="string">"#"</span>);</span><br><span class="line">		 c.add(<span class="string">"two"</span>);</span><br><span class="line">		 c.add(<span class="string">"#"</span>);</span><br><span class="line">		 c.add(<span class="string">"three"</span>);</span><br><span class="line">		 c.add(<span class="string">"#"</span>);</span><br><span class="line">		 c.add(<span class="string">"four"</span>);</span><br><span class="line">		 c.add(<span class="string">"#"</span>);</span><br><span class="line">		 c.add(<span class="string">"five"</span>);</span><br><span class="line">		 System.out.println(c);</span><br><span class="line">		 </span><br><span class="line">		 Iterator it = c.iterator();</span><br><span class="line">		 /*</span><br><span class="line">		  * boolean hasNext()</span><br><span class="line">		  * 通过迭代器判断集合是否含有元素可以遍历</span><br><span class="line">		  */</span><br><span class="line">		 <span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">			 /*</span><br><span class="line">			  * E next()</span><br><span class="line">			  * 获取集合下一个元素</span><br><span class="line">			  */</span><br><span class="line">			 String s = (String)it.next();</span><br><span class="line">			 System.out.println(s);</span><br><span class="line">			 <span class="keyword">if</span>(<span class="string">"#"</span>.equals(s)) &#123;</span><br><span class="line">				 /*</span><br><span class="line">				  * 迭代器遍历集合有一个要求，遍历的过程中不能</span><br><span class="line">				  * 通过集合的方法增删元素，否则会抛出异常</span><br><span class="line">				  */</span><br><span class="line">				 //c.remove(s);</span><br><span class="line">				 /*</span><br><span class="line">				  * 迭代器的remove方法不需要传参，</span><br><span class="line">				  * 删除的就是本次遍历时next()得到的元素。</span><br><span class="line">				  */</span><br><span class="line">				 it.remove();</span><br><span class="line">			 &#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		 System.out.println(c);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="增强for-循环"><a href="#增强for-循环" class="headerlink" title="增强for 循环"></a>增强for 循环</h3><ul>
<li><strong>For-Each循环也叫增强型的for循环，或者叫foreach循环。</strong></li>
<li><strong>For-Each循环是JDK5.0的新特性（其他新特性比如泛型、自动装箱等）。</strong></li>
<li><p><strong>For-Each循环的加入简化了集合的遍历。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type element : array)&#123;</span><br><span class="line">		System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>For-Each循环的缺点：丢掉了索引信息。</strong></p>
<ul>
<li><strong>当遍历集合或数组时，如果需要访问集合或数组的下标，那么最好使用旧式的方式来实现循环或遍历，而不要使用增强的for循环，因为它丢失了下标信息。</strong></li>
</ul>
</li>
</ul>
<h3 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h3><ul>
<li><strong>Java 泛型是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</strong></li>
<li><strong>Java泛型机制广泛的应用在集合框架中。所有的集合类型都带有泛型参数，这样在创建集合时可以指定放入集合中元素的类型。Java编译器可以根据此类型进行检查，这样可以减少代码在运行时出现错误的可能性。</strong></li>
</ul>
<h3 id="泛型在集合中的应用"><a href="#泛型在集合中的应用" class="headerlink" title="泛型在集合中的应用"></a>泛型在集合中的应用</h3><ul>
<li><strong>ArrayList类的定义中，&lt; E &gt;中的E为泛型参数，在创建对象时可以将类型作为参数传递，此时，类定义所有的E将替换成传入的参数。</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">	... ... ...</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>&#123;...&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>&#123;...&#125;;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">"one"</span>);</span><br><span class="line"><span class="comment">//list.add(100);  Java编译器类型检查错误，此时add方法应传入的参数类型是String</span></span><br></pre></td></tr></table></figure></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/21/Thread-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/21/Thread-2/" itemprop="url">Thread-2</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-21T18:31:12+08:00">
                2019-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="多线程-2"><a href="#多线程-2" class="headerlink" title="多线程 - 2"></a>多线程 - 2</h3><h4 id="使用内部类创建线程"><a href="#使用内部类创建线程" class="headerlink" title="使用内部类创建线程"></a>使用内部类创建线程</h4><ul>
<li><strong>通常我们可以通过匿名内部类的方式创建线程，使用该方式可以简化编写代码的复杂度，当一个线程仅需要一个实例时我们通常使用这种方式来创建。</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">创建方式：</span><br><span class="line">		Thread t = new <span class="function"><span class="title">Thread</span></span>()&#123;</span><br><span class="line">			public void <span class="function"><span class="title">run</span></span>() &#123;</span><br><span class="line">				//线程体</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		t.start();//启动线程</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h4><ul>
<li><strong>synchronized是Java中的关键字，是一种同步锁。它修饰的对象有以下几种：</strong> </li>
</ul>
<ol>
<li><strong>修饰一个代码块，被修饰的代码块称为同步语句块，其作用的范围是大括号{}括起来的代码，作用的对象是调用这个代码块的对象；</strong> </li>
<li><strong>修饰一个方法，被修饰的方法称为同步方法，其作用的范围是整个方法，作用的对象是调用这个方法的对象；</strong> </li>
<li><strong>修改一个静态的方法，其作用的范围是整个静态方法，作用的对象是这个类的所有对象；</strong> </li>
<li><strong>修改一个类，其作用的范围是synchronized后面括号括起来的部分，作用主的对象是这个类的所有对象。</strong></li>
</ol>
<ul>
<li><strong>实现原理：<br>JVM 是通过进入、退出对象监视器( Monitor )来实现对方法、同步块的同步的。<br>具体实现是在编译之后在同步方法调用前加入一个 monitor.enter 指令，在退出方法和异常处插入 monitor.exit 的指令。其本质就是对一个对象监视器( Monitor )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 monitor.exit 之后才能尝试继续获取锁。</strong></li>
</ul>
<h4 id="锁机制"><a href="#锁机制" class="headerlink" title="锁机制"></a>锁机制</h4><ul>
<li><strong>Java提供了一种内置的锁机制来支持原子性:</strong></li>
<li><strong>同步代码块（synchronized），同步代码快包含两部分:一个作为锁的对象的引用，一个作为由这个。</strong></li>
<li><strong>若方法所有代码都需要同步也可以给方法直接加锁。</strong></li>
<li><strong>每个Java对象都可以用做一个实现同步的锁，线程进入同步代码快之前会自动获得锁，并且在退出同步代码时自动释放锁，而且无论是通过正常途径还是通过抛异常退出都一样，获得内置锁的唯一途径就是进入由这个锁保护的同步代码块或方法。</strong></li>
<li><strong>选择合适锁对象：</strong><ul>
<li><strong>使用synchroinzed需要对一个对象上锁以保证线程同步。</strong></li>
<li><strong>多个需要同步的线程在访问该同步块时，看到的应该是同一个所对象引用。否则达不到同步效果。</strong></li>
<li><strong>通常我们会使用this来作为锁对象。</strong></li>
</ul>
</li>
<li><strong>选择合适锁范围：</strong><ul>
<li><strong>在使用同步块时，应当尽量在允许的情况下减少同步范围，以提高并发的执行效率。</strong></li>
</ul>
</li>
</ul>
<h4 id="静态方法锁"><a href="#静态方法锁" class="headerlink" title="静态方法锁"></a>静态方法锁</h4><ul>
<li><strong>当我们对一个静态方法加锁，那么该方法锁的对象是类对象。每个类都有唯一的一个类对象。获取类对象的方式: 类名.class</strong></li>
<li><strong>静态方法与非静态方法同时声明了synchronized，他们之间是非互斥关系的。原因在于，静态方法锁的是类对象而非静态方法锁的是当前方法所属对象。</strong></li>
</ul>
<h4 id="使用ExecutorService实现线程池"><a href="#使用ExecutorService实现线程池" class="headerlink" title="使用ExecutorService实现线程池"></a>使用ExecutorService实现线程池</h4><ul>
<li><strong>ExecutorService是java提供的用于管理线程池的类。</strong></li>
<li><strong>线程池有两个主要作用：</strong><ul>
<li><strong>控制线程数量</strong></li>
<li><strong>重用线程</strong></li>
</ul>
</li>
<li><strong>当一个程序中创建大量线程，并在任务结束后销毁，会给系统带来过度消耗资源，以及过度切换线程的危险，从而可能导致系统崩溃。</strong></li>
<li><strong>概念：</strong><ul>
<li><strong>首先创建一些线程，他们的集合称为线程池，当服务器接收到一个客户请求后，就从线程池中取出一个空闲的线程为之服务，服务完成后不关闭该线程，而是将该线程还回到线程池中。</strong></li>
<li><strong>在线程池的编程模式下，任务是提交给整个线程池，而不是直接交给某个线程，线程池在拿到任务后，他就在内部找有无空闲的线程，再把任务交给内部某个空闲的线程。一个线程同时只能执行一个任务，但是可以同时向一个线程池提交多个任务。</strong></li>
</ul>
</li>
<li><strong>线程池的几种实现策略：</strong><ul>
<li><strong>Executors.newCachedThreadPool()：</strong><ul>
<li><strong>创建一个可以根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。</strong></li>
</ul>
</li>
<li><strong>Executors.newFixedThreadPoll(int nThreads)：</strong><ul>
<li><strong>创建一个可重用固定线程集合的线程池，以共享的无界队列方式来运行这些线程。</strong></li>
</ul>
</li>
<li><strong>Executors.newScheduledThreadPool(int corePoolSize)：</strong><ul>
<li><strong>创建一个线程池，它可安排在给定延迟后运行命令或者定期的执行。</strong></li>
</ul>
</li>
<li><strong>Executors.newSingleThreadExecutor()：</strong><ul>
<li><strong>创建一个使用单个worker线程的Executor，以无界队列方式来运行该线程。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h4><ul>
<li><strong>BlockingQueue从字面意思就知道它是阻塞队列，它在以下两种情况会造成阻塞:</strong></li>
</ul>
<ol>
<li><strong>当队列满了的时候进行入队操作。</strong></li>
<li><strong>当队列空了的时候进行出队操作。</strong><br><strong>也就是说，当一个线程对已经满了的队列进行入队操作时，会被阻塞，除非另外一个线程进行了出队操作。或者当一个线程对一个空的队列进行出队操作的时候，会被阻塞，除非另外一个线程进行了入队的操作。</strong></li>
</ol>
<ul>
<li><strong>阻塞队列是线程安全的，主要用于生产者/消费者的场景。比如一个线程在队尾进行put操作，另外一个线程在队头进行take操作。需要注意的是BlockingQueue不能插入Null值，否则会报NullPointerException异常。</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:center">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入方法</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center">put(e)</td>
<td style="text-align:center">offer(e,time,unit)</td>
</tr>
<tr>
<td style="text-align:center">移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center">take()</td>
<td style="text-align:center">poll(time,unit)</td>
</tr>
<tr>
<td style="text-align:center">检查方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">不可用</td>
<td style="text-align:center">不可用</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/Thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/Thread/" itemprop="url">Thread-1</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T18:28:27+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="JAVA-多线程"><a href="#JAVA-多线程" class="headerlink" title="JAVA 多线程"></a>JAVA 多线程</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li><strong>Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。</strong></li>
<li><strong>这里定义和线程相关的另一个术语 - 进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。</strong></li>
<li><strong>多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。</strong></li>
</ul>
<h4 id="线程的几个主要概念"><a href="#线程的几个主要概念" class="headerlink" title="线程的几个主要概念"></a>线程的几个主要概念</h4><ol>
<li><strong>线程同步</strong></li>
<li><strong>线程间通信</strong></li>
<li><strong>线程死锁</strong></li>
<li><strong>线程控制：挂起、停止和恢复</strong></li>
</ol>
<h4 id="进程与线程的区别"><a href="#进程与线程的区别" class="headerlink" title="进程与线程的区别"></a>进程与线程的区别</h4><ul>
<li><strong>简而言之,一个程序至少有一个进程,一个进程至少有一个线程. </strong></li>
<li><strong>线程的划分尺度小于进程，使得多线程程序的并发性高。另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</strong></li>
<li><strong>线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。</strong></li>
<li><strong>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.</strong></li>
<li><strong>线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行</strong></li>
<li><strong>进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。</strong></li>
</ul>
<h4 id="多线程的使用"><a href="#多线程的使用" class="headerlink" title="多线程的使用"></a>多线程的使用</h4><ul>
<li><strong>有效利用多线程的关键是理解程序是并发执行而不是串行执行的。例如：程序中有两个子系统需要并发执行，这时候就需要利用多线程编程。通过对多线程的使用，可以编写出非常高效的程序。不过请注意，如果你创建太多的线程，程序执行的效率实际上是降低了，而不是提升了。请记住，上下文的切换开销也很重要，如果你创建了太多的线程，CPU 花费在上下文的切换的时间将多于执行程序的时间！</strong></li>
</ul>
<h4 id="并发原理"><a href="#并发原理" class="headerlink" title="并发原理"></a>并发原理</h4><ul>
<li><strong>多个线程“同时”运行只是我们感观上的一种表现。事实上线程是并发运行的，操作系统将时间划分为很多时间段，尽可能的均匀分配给每一个线程，获取到时间片的线程被CPU执行，其他则一直在等待。所以微观上是走走停停，宏观上都在运行。这种现象叫并发，但不是绝对意义上的同时发生。实则操作系统里面“同一时刻”只有一个线程在执行，但是处理速率快，效果上是并发运行。</strong></li>
</ul>
<h4 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h4><ul>
<li><strong>每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。</strong></li>
<li><strong>Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。<br>默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。</strong></li>
<li><strong>具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。</strong></li>
</ul>
<h4 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h4><ul>
<li><strong>通过实现 Runnable 接口；</strong></li>
<li><strong>通过继承 Thread 类本身；</strong></li>
<li><strong>通过 Callable 和 Future 创建线程。</strong></li>
</ul>
<ol>
<li><strong>通过实现Runnable接口创建线程</strong><ul>
<li><strong>实现Runnable接口并重写run方法来定义线程体，然后在创建线程的时候将Runnable的实例传入并启动线程。这样做的好处在于将线程和线程执行的任务分离开解耦合。同时Java是单继承，实现接口可以更好的让该类去继承其他类。</strong></li>
</ul>
</li>
<li><strong>通过继承Thread来创建线程</strong><ul>
<li><strong>创建一个新的类，该类继承 Thread 类，然后创建一个该类的实例。继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。</strong></li>
</ul>
</li>
</ol>
<h5 id="Thread类的一些重要方法："><a href="#Thread类的一些重要方法：" class="headerlink" title="Thread类的一些重要方法："></a>Thread类的一些重要方法：</h5><ul>
<li><p><strong>测试线程是否处于活动状态。 被Thread对象调用的。</strong></p>
<ul>
<li><strong>public void start()</strong><ul>
<li><strong>使该线程开始执行；Java 虚拟机调用该线程的 run 方法。</strong></li>
</ul>
</li>
<li><strong>public void run()</strong><ul>
<li><strong>如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。</strong></li>
</ul>
</li>
<li><strong>public final void setName(String name)</strong><ul>
<li><strong>改变线程名称，使之与参数 name 相同。</strong></li>
</ul>
</li>
<li><strong>public final void setPriority(int priority)</strong><ul>
<li><strong>更改线程的优先级。</strong></li>
</ul>
</li>
<li><strong>public final void setDaemon(boolean on)</strong><ul>
<li><strong>将该线程标记为守护线程或用户线程。</strong></li>
</ul>
</li>
<li><strong>public final void join(long millisec)</strong><ul>
<li><strong>等待该线程终止的时间最长为 millis 毫秒。</strong></li>
</ul>
</li>
<li><strong>public void interrupt()</strong><ul>
<li><strong>中断线程。</strong></li>
</ul>
</li>
<li><strong>public final boolean isAlive()</strong><ul>
<li><strong>测试线程是否处于活动状态。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Thread类的静态方法：</strong></p>
<ul>
<li><strong>public static void yield()</strong><ul>
<li><strong>暂停当前正在执行的线程对象，并执行其他线程。</strong></li>
</ul>
</li>
<li><strong>public static void sleep(long millisec)</strong><ul>
<li><strong>在指定的毫秒数内让当前正在执行的线程休眠（暂停执行），此操作受到系统计时器和调度程序精度和准确性的影响。</strong></li>
</ul>
</li>
<li><strong>public static boolean holdsLock(Object x)</strong><ul>
<li><strong>当且仅当当前线程在指定的对象上保持监视器锁时，才返回 true。</strong></li>
</ul>
</li>
<li><strong>public static Thread currentThread()</strong><ul>
<li><strong>返回对当前正在执行的线程对象的引用。</strong></li>
</ul>
</li>
<li><strong>public static void dumpStack()</strong><ul>
<li><strong>将当前线程的堆栈跟踪打印至标准错误流。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>通过 Callable 和 Future 创建线程</strong><ul>
<li><strong>创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。</strong></li>
<li><strong>创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。</strong></li>
<li><strong>使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。</strong></li>
<li><strong>调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。</strong></li>
</ul>
</li>
</ol>
<h4 id="创建线程的三种方式的对比"><a href="#创建线程的三种方式的对比" class="headerlink" title="创建线程的三种方式的对比"></a>创建线程的三种方式的对比</h4><ul>
<li><strong>采用实现 Runnable、Callable 接口的方式创建多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。</strong></li>
<li><strong>使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/TCP/" itemprop="url">TCP通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T14:41:21+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Socket-原理"><a href="#Socket-原理" class="headerlink" title="Socket 原理"></a>Socket 原理</h3><h4 id="Socket-简介"><a href="#Socket-简介" class="headerlink" title="Socket 简介"></a>Socket 简介</h4><ul>
<li><strong>socket起源于Unix，而Unix/Linux基本哲学之一就是：“一切即文件”，都可以用”打开open -&gt; 读写write/read -&gt; 关闭close”模式来操作。</strong></li>
<li><strong>简单来说socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作(读/写IO,关闭，打开)。</strong></li>
<li><strong>我们在传输数据的时候，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用成协议，应用层协议有很多，比如HTTP,FTP,TELNET等，也可以自己定义应用层协议。WEB协议使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP协议作传输层协议将它发到网络上。</strong></li>
</ul>
<h4 id="Socket概念"><a href="#Socket概念" class="headerlink" title="Socket概念"></a>Socket概念</h4><ul>
<li><strong>Socket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP/IP连接等等。而TCP和UDP协议属于传输层。而HTTP是个应用层的协议，它实际上也建立在 TCP协议之上.（HTTP是轿车，提供了封装或者是现实数据的具体形式；socket是发动机，提供了网络通信的能力)。</strong></li>
<li><strong>socket称为”套接字”,适用于网络通信的方法。socket是对tcp/IP协议的封装，socket本身并不是协议，而是一个调用接口(api)。通过socket我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</strong></li>
</ul>
<h4 id="获取本地地址和端口号"><a href="#获取本地地址和端口号" class="headerlink" title="获取本地地址和端口号"></a>获取本地地址和端口号</h4><ul>
<li><strong>java.net.Socket为套接字类，通过Socke获取：</strong><ul>
<li><strong>int getLocalPort() :</strong><ul>
<li><strong>用获取本地使用的端口号</strong></li>
</ul>
</li>
<li><strong>getLocalSocketAddress() </strong><ul>
<li><strong>返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。</strong></li>
</ul>
</li>
<li><strong>IntAddress getLocalAddress() :</strong><ul>
<li><strong>用于获取套接字绑定的本地地址</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>使用InetAddress获取本地的地址方法:</strong><ul>
<li><strong>String getCanonicalHostName() :</strong><ul>
<li><strong>获取此IP地址的完全限定域名</strong></li>
</ul>
</li>
<li><strong>String getHostAddress() :</strong><ul>
<li><strong>返回IP地址字符串（以文本表现形式）</strong></li>
</ul>
</li>
<li><strong>String getCanonicalHostName() :</strong><ul>
<li><strong>获取此 IP 地址的完全限定域名。</strong></li>
</ul>
</li>
<li><strong>String getHostName() :</strong> <ul>
<li><strong>获取此 IP 地址的主机名。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="获取远端地址和端口号"><a href="#获取远端地址和端口号" class="headerlink" title="获取远端地址和端口号"></a>获取远端地址和端口号</h4><ul>
<li><strong>通过Socket获取：</strong><ul>
<li><strong>int getPort() :</strong><ul>
<li><strong>用于获取远端使用的端口号</strong></li>
</ul>
</li>
<li><strong>InetAddress .getInetAddress() :</strong><ul>
<li><strong>用于获取套接字绑定的远端地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="获取网络输入流和网络输出流"><a href="#获取网络输入流和网络输出流" class="headerlink" title="获取网络输入流和网络输出流"></a>获取网络输入流和网络输出流</h4><ul>
<li><p><strong>通过Socket获取输入流与输出流：</strong></p>
<ul>
<li><strong>InputStream getInputStream() :</strong><ul>
<li><strong>用于返回套接字的输入流</strong></li>
</ul>
</li>
<li><strong>OutputStream getOutputStream() :</strong><ul>
<li><strong>用于返回套接字的输出流</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>close方法：当使用Socket进行通讯完毕后，要关闭Socket以释放系统资源。</strong></p>
</li>
<li><strong>void close() ：</strong><ul>
<li><strong>关闭此套接字。当关闭了该套接字后也会同时关闭由此获取的输入流与输出流</strong></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/Exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/Exception/" itemprop="url">Exception</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T21:44:48+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="JAVA异常概念"><a href="#JAVA异常概念" class="headerlink" title="JAVA异常概念"></a>JAVA异常概念</h3><ul>
<li><strong>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</strong></li>
<li><strong>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error</strong></li>
</ul>
<h4 id="异常发生的原因有很多，通常包含以下几大类："><a href="#异常发生的原因有很多，通常包含以下几大类：" class="headerlink" title="异常发生的原因有很多，通常包含以下几大类："></a>异常发生的原因有很多，通常包含以下几大类：</h4><ul>
<li><strong>用户输入了非法数据。</strong></li>
<li><strong>要打开的文件不存在。</strong></li>
<li><strong>网络通信时连接中断，或者JVM内存溢出。</strong><br><strong>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</strong></li>
</ul>
<h4 id="要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常："><a href="#要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：" class="headerlink" title="要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常："></a>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</h4><ul>
<li><strong>检查性异常：</strong><ul>
<li><strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</strong></li>
</ul>
</li>
<li><strong>运行时异常：</strong><ul>
<li><strong>运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</strong></li>
</ul>
</li>
<li><strong>错误：</strong><ul>
<li><strong>错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</strong></li>
</ul>
</li>
</ul>
<h3 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h3><ul>
<li><strong>所有的异常类是从 java.lang.Exception 类继承的子类。</strong></li>
<li><strong>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</strong></li>
</ul>
<h3 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h3><ul>
<li><strong>Java 语言定义了一些异常类在 java.lang 标准包中。</strong></li>
<li><p><strong>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</strong></p>
</li>
<li><p><strong>Java 的非检查性异常:</strong></p>
<ul>
<li><strong>ArithmeticException： 当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</strong> </li>
<li><strong>ArrayIndexOutOfBoundsException： 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</strong> </li>
<li><strong>ArrayStoreException： 试图将错误类型的对象存储到一个对象数组时抛出的异常。</strong> </li>
<li><strong>ClassCastException： 当试图将对象强制转换为不是实例的子类时，抛出该异常。</strong> </li>
<li><strong>IllegalArgumentException： 抛出的异常表明向方法传递了一个不合法或不正确的参数。</strong> </li>
<li><strong>IllegalMonitorStateException： 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</strong> </li>
<li><strong>IllegalStateException： 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</strong> </li>
<li><strong>IllegalThreadStateException： 线程没有处于请求操作所要求的适当状态时抛出的异常。</strong> </li>
<li><strong>IndexOutOfBoundsException： 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</strong> </li>
<li><strong>NegativeArraySizeException： 如果应用程序试图创建大小为负的数组，则抛出该异常。</strong> </li>
<li><strong>NullPointerException： 当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</strong> </li>
<li><strong>NumberFormatException： 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</strong> </li>
<li><strong>SecurityException： 由安全管理器抛出的异常，指示存在安全侵犯。</strong> </li>
<li><strong>StringIndexOutOfBoundsException： 此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</strong> </li>
<li><strong>UnsupportedOperationException： 当不支持请求的操作时，抛出该异常。</strong> </li>
</ul>
</li>
<li><p><strong>Java 定义在 java.lang 包中的检查性异常类：</strong></p>
<ul>
<li><strong>ClassNotFoundException： 应用程序试图加载类时，找不到相应的类，抛出该异常。</strong> </li>
<li><strong>CloneNotSupportedException： 当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</strong></li>
<li><strong>IllegalAccessException： 拒绝访问一个类的时候，抛出该异常。</strong></li>
<li><strong>InstantiationException： 当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</strong> </li>
<li><strong>InterruptedException： 一个线程被另一个线程中断，抛出该异常。</strong> </li>
<li><strong>NoSuchFieldException： 请求的变量不存在</strong> </li>
<li><strong>NoSuchMethodException： 请求的方法不存在</strong></li>
</ul>
</li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul>
<li><p><strong>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。<br>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">代码块</span><br><span class="line">&#125;catch(XXXExecption e)&#123;</span><br><span class="line">处理try中出现的XXXExecption的代码片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当出现了异常时，JVM会实例化该异常的实例并将其抛出</strong></p>
</li>
</ul>
<h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><ul>
<li><strong>catch是可以定义多个的，当针对不同的异常,我们有不同的处理手段时，我们可以分别捕获这些异常并处理。但应当有一个好的习惯，在最后一个catch中捕获Exception，Exception,可以防止因为一个未处理的异常导致程序中断。</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   // 程序代码</span><br><span class="line">&#125;catch(异常类型1 异常的变量名1)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h3><ul>
<li><strong>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</strong></li>
<li><strong>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</strong></li>
<li><strong>使用throw关键字可以将一个异常抛出。通常如下情况我们会对外主动抛出异常:</strong><ul>
<li><strong>1.程序执行中发现一个满足语法要求，但是不满足业务逻辑要求的情况时,可以对外抛出异常告知不应当这样做。</strong></li>
<li><strong>2.程序确实出现了异常，但是该异常不应当在当前代码片段中被解决时,可以对外抛出给调用者解决(责任制问题)</strong></li>
</ul>
</li>
<li><strong>当我们调用一个含有throws声明异常抛出的方法时，编译器要求我们必须处理这个异常，否则编译不通过。</strong><ul>
<li><strong>两种处理方式：</strong><ul>
<li><strong>1.使用try-catch捕获并处理这个异常</strong></li>
<li><strong>2.在当前方法上继续使用throws将这个异常抛出,具体选择哪种解决方式取决于处理异常的责任问题</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><ul>
<li><strong>finally块是异常处理机制的最后一块，可以直接跟在try块之后或者最后一个catch之后。</strong></li>
<li><strong>finally块可以确保只要代码执行到try当中，无论try块 当中的代码是否抛出异常，finally块中的代码都必定执行，通常我们将释放的资源这样的操作放在finally中确保执行， 比如IO中关闭流的操作。</strong></li>
</ul>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li><strong>catch 不能独立于 try 存在。</strong></li>
<li><strong>在 try/catch 后面添加 finally 块并非强制性要求的。</strong></li>
<li><strong>try 代码后不能既没 catch 块也没 finally 块。</strong></li>
<li><strong>try, catch, finally 块之间不能添加任何代码。</strong></li>
</ul>
<h3 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h3><p><strong>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</strong></p>
<ul>
<li><strong>所有异常都必须是 Throwable 的子类。</strong></li>
<li><strong>如果希望写一个检查性异常类，则需要继承 Exception 类。</strong></li>
<li><strong>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</strong></li>
</ul>
<h3 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h3><p><strong>在Java中定义了两种类型的异常和错误。</strong></p>
<ul>
<li><strong>JVM(Java虚拟机)异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</strong></li>
<li><strong>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alone5</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">68</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alone5</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
