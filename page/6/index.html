<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Wt Blog">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="Wt Blog">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wt Blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>Wt Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wt Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/TCP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/18/TCP/" itemprop="url">TCP通信</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-18T14:41:21+08:00">
                2019-05-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Socket-原理"><a href="#Socket-原理" class="headerlink" title="Socket 原理"></a>Socket 原理</h3><h4 id="Socket-简介"><a href="#Socket-简介" class="headerlink" title="Socket 简介"></a>Socket 简介</h4><ul>
<li><strong>socket起源于Unix，而Unix/Linux基本哲学之一就是：“一切即文件”，都可以用”打开open -&gt; 读写write/read -&gt; 关闭close”模式来操作。</strong></li>
<li><strong>简单来说socket就是该模式的一个实现，socket即是一种特殊的文件，一些socket函数就是对其进行的操作(读/写IO,关闭，打开)。</strong></li>
<li><strong>我们在传输数据的时候，可以只使用（传输层）TCP/IP协议，但是那样的话，如果没有应用层，便无法识别数据内容，如果想要使传输的数据有意义，则必须使用到应用成协议，应用层协议有很多，比如HTTP,FTP,TELNET等，也可以自己定义应用层协议。WEB协议使用HTTP协议作应用层协议，以封装HTTP文本信息，然后使用TCP/IP协议作传输层协议将它发到网络上。</strong></li>
</ul>
<h4 id="Socket概念"><a href="#Socket概念" class="headerlink" title="Socket概念"></a>Socket概念</h4><ul>
<li><strong>Socket是一个针对TCP和UDP编程的接口，你可以借助它建立TCP/IP连接等等。而TCP和UDP协议属于传输层。而HTTP是个应用层的协议，它实际上也建立在 TCP协议之上.（HTTP是轿车，提供了封装或者是现实数据的具体形式；socket是发动机，提供了网络通信的能力)。</strong></li>
<li><strong>socket称为”套接字”,适用于网络通信的方法。socket是对tcp/IP协议的封装，socket本身并不是协议，而是一个调用接口(api)。通过socket我们才能使用TCP/IP协议。Socket的出现只是使得程序员更方便地使用TCP/IP协议栈而已，是对TCP/IP协议的抽象，从而形成了我们知道的一些最基本的函数接口。</strong></li>
</ul>
<h4 id="获取本地地址和端口号"><a href="#获取本地地址和端口号" class="headerlink" title="获取本地地址和端口号"></a>获取本地地址和端口号</h4><ul>
<li><strong>java.net.Socket为套接字类，通过Socke获取：</strong><ul>
<li><strong>int getLocalPort() :</strong><ul>
<li><strong>用获取本地使用的端口号</strong></li>
</ul>
</li>
<li><strong>getLocalSocketAddress() </strong><ul>
<li><strong>返回此套接字绑定的端点的地址，如果尚未绑定则返回 null。</strong></li>
</ul>
</li>
<li><strong>IntAddress getLocalAddress() :</strong><ul>
<li><strong>用于获取套接字绑定的本地地址</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>使用InetAddress获取本地的地址方法:</strong><ul>
<li><strong>String getCanonicalHostName() :</strong><ul>
<li><strong>获取此IP地址的完全限定域名</strong></li>
</ul>
</li>
<li><strong>String getHostAddress() :</strong><ul>
<li><strong>返回IP地址字符串（以文本表现形式）</strong></li>
</ul>
</li>
<li><strong>String getCanonicalHostName() :</strong><ul>
<li><strong>获取此 IP 地址的完全限定域名。</strong></li>
</ul>
</li>
<li><strong>String getHostName() :</strong> <ul>
<li><strong>获取此 IP 地址的主机名。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="获取远端地址和端口号"><a href="#获取远端地址和端口号" class="headerlink" title="获取远端地址和端口号"></a>获取远端地址和端口号</h4><ul>
<li><strong>通过Socket获取：</strong><ul>
<li><strong>int getPort() :</strong><ul>
<li><strong>用于获取远端使用的端口号</strong></li>
</ul>
</li>
<li><strong>InetAddress .getInetAddress() :</strong><ul>
<li><strong>用于获取套接字绑定的远端地址</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="获取网络输入流和网络输出流"><a href="#获取网络输入流和网络输出流" class="headerlink" title="获取网络输入流和网络输出流"></a>获取网络输入流和网络输出流</h4><ul>
<li><p><strong>通过Socket获取输入流与输出流：</strong></p>
<ul>
<li><strong>InputStream getInputStream() :</strong><ul>
<li><strong>用于返回套接字的输入流</strong></li>
</ul>
</li>
<li><strong>OutputStream getOutputStream() :</strong><ul>
<li><strong>用于返回套接字的输出流</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>close方法：当使用Socket进行通讯完毕后，要关闭Socket以释放系统资源。</strong></p>
</li>
<li><strong>void close() ：</strong><ul>
<li><strong>关闭此套接字。当关闭了该套接字后也会同时关闭由此获取的输入流与输出流</strong></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/Exception/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/15/Exception/" itemprop="url">Exception</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-15T21:44:48+08:00">
                2019-05-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="JAVA异常概念"><a href="#JAVA异常概念" class="headerlink" title="JAVA异常概念"></a>JAVA异常概念</h3><ul>
<li><strong>异常是程序中的一些错误，但并不是所有的错误都是异常，并且错误有时候是可以避免的。</strong></li>
<li><strong>比如说，你的代码少了一个分号，那么运行出来结果是提示是错误 java.lang.Error</strong></li>
</ul>
<h4 id="异常发生的原因有很多，通常包含以下几大类："><a href="#异常发生的原因有很多，通常包含以下几大类：" class="headerlink" title="异常发生的原因有很多，通常包含以下几大类："></a>异常发生的原因有很多，通常包含以下几大类：</h4><ul>
<li><strong>用户输入了非法数据。</strong></li>
<li><strong>要打开的文件不存在。</strong></li>
<li><strong>网络通信时连接中断，或者JVM内存溢出。</strong><br><strong>这些异常有的是因为用户错误引起，有的是程序错误引起的，还有其它一些是因为物理错误引起的。</strong></li>
</ul>
<h4 id="要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常："><a href="#要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：" class="headerlink" title="要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常："></a>要理解Java异常处理是如何工作的，你需要掌握以下三种类型的异常：</h4><ul>
<li><strong>检查性异常：</strong><ul>
<li><strong>最具代表的检查性异常是用户错误或问题引起的异常，这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略。</strong></li>
</ul>
</li>
<li><strong>运行时异常：</strong><ul>
<li><strong>运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略。</strong></li>
</ul>
</li>
<li><strong>错误：</strong><ul>
<li><strong>错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的。</strong></li>
</ul>
</li>
</ul>
<h3 id="Exception-类的层次"><a href="#Exception-类的层次" class="headerlink" title="Exception 类的层次"></a>Exception 类的层次</h3><ul>
<li><strong>所有的异常类是从 java.lang.Exception 类继承的子类。</strong></li>
<li><strong>Exception 类是 Throwable 类的子类。除了Exception类外，Throwable还有一个子类Error 。</strong></li>
</ul>
<h3 id="Java-内置异常类"><a href="#Java-内置异常类" class="headerlink" title="Java 内置异常类"></a>Java 内置异常类</h3><ul>
<li><strong>Java 语言定义了一些异常类在 java.lang 标准包中。</strong></li>
<li><p><strong>标准运行时异常类的子类是最常见的异常类。由于 java.lang 包是默认加载到所有的 Java 程序的，所以大部分从运行时异常类继承而来的异常都可以直接使用。</strong></p>
</li>
<li><p><strong>Java 的非检查性异常:</strong></p>
<ul>
<li><strong>ArithmeticException： 当出现异常的运算条件时，抛出此异常。例如，一个整数”除以零”时，抛出此类的一个实例。</strong> </li>
<li><strong>ArrayIndexOutOfBoundsException： 用非法索引访问数组时抛出的异常。如果索引为负或大于等于数组大小，则该索引为非法索引。</strong> </li>
<li><strong>ArrayStoreException： 试图将错误类型的对象存储到一个对象数组时抛出的异常。</strong> </li>
<li><strong>ClassCastException： 当试图将对象强制转换为不是实例的子类时，抛出该异常。</strong> </li>
<li><strong>IllegalArgumentException： 抛出的异常表明向方法传递了一个不合法或不正确的参数。</strong> </li>
<li><strong>IllegalMonitorStateException： 抛出的异常表明某一线程已经试图等待对象的监视器，或者试图通知其他正在等待对象的监视器而本身没有指定监视器的线程。</strong> </li>
<li><strong>IllegalStateException： 在非法或不适当的时间调用方法时产生的信号。换句话说，即 Java 环境或 Java 应用程序没有处于请求操作所要求的适当状态下。</strong> </li>
<li><strong>IllegalThreadStateException： 线程没有处于请求操作所要求的适当状态时抛出的异常。</strong> </li>
<li><strong>IndexOutOfBoundsException： 指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。</strong> </li>
<li><strong>NegativeArraySizeException： 如果应用程序试图创建大小为负的数组，则抛出该异常。</strong> </li>
<li><strong>NullPointerException： 当应用程序试图在需要对象的地方使用 <code>null</code> 时，抛出该异常</strong> </li>
<li><strong>NumberFormatException： 当应用程序试图将字符串转换成一种数值类型，但该字符串不能转换为适当格式时，抛出该异常。</strong> </li>
<li><strong>SecurityException： 由安全管理器抛出的异常，指示存在安全侵犯。</strong> </li>
<li><strong>StringIndexOutOfBoundsException： 此异常由 <code>String</code> 方法抛出，指示索引或者为负，或者超出字符串的大小。</strong> </li>
<li><strong>UnsupportedOperationException： 当不支持请求的操作时，抛出该异常。</strong> </li>
</ul>
</li>
<li><p><strong>Java 定义在 java.lang 包中的检查性异常类：</strong></p>
<ul>
<li><strong>ClassNotFoundException： 应用程序试图加载类时，找不到相应的类，抛出该异常。</strong> </li>
<li><strong>CloneNotSupportedException： 当调用 <code>Object</code> 类中的 <code>clone</code> 方法克隆对象，但该对象的类无法实现 <code>Cloneable</code> 接口时，抛出该异常。</strong></li>
<li><strong>IllegalAccessException： 拒绝访问一个类的时候，抛出该异常。</strong></li>
<li><strong>InstantiationException： 当试图使用 <code>Class</code> 类中的 <code>newInstance</code> 方法创建一个类的实例，而指定的类对象因为是一个接口或是一个抽象类而无法实例化时，抛出该异常。</strong> </li>
<li><strong>InterruptedException： 一个线程被另一个线程中断，抛出该异常。</strong> </li>
<li><strong>NoSuchFieldException： 请求的变量不存在</strong> </li>
<li><strong>NoSuchMethodException： 请求的方法不存在</strong></li>
</ul>
</li>
</ul>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><ul>
<li><p><strong>使用 try 和 catch 关键字可以捕获异常。try/catch 代码块放在异常可能发生的地方。<br>try/catch代码块中的代码称为保护代码，使用 try/catch 的语法如下：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">代码块</span><br><span class="line">&#125;catch(XXXExecption e)&#123;</span><br><span class="line">处理try中出现的XXXExecption的代码片段</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当出现了异常时，JVM会实例化该异常的实例并将其抛出</strong></p>
</li>
</ul>
<h3 id="多重捕获块"><a href="#多重捕获块" class="headerlink" title="多重捕获块"></a>多重捕获块</h3><ul>
<li><strong>catch是可以定义多个的，当针对不同的异常,我们有不同的处理手段时，我们可以分别捕获这些异常并处理。但应当有一个好的习惯，在最后一个catch中捕获Exception，Exception,可以防止因为一个未处理的异常导致程序中断。</strong><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">   // 程序代码</span><br><span class="line">&#125;catch(异常类型1 异常的变量名1)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;catch(异常类型2 异常的变量名2)&#123;</span><br><span class="line">  // 程序代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="throws-throw-关键字："><a href="#throws-throw-关键字：" class="headerlink" title="throws/throw 关键字："></a>throws/throw 关键字：</h3><ul>
<li><strong>如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。</strong></li>
<li><strong>一个方法可以声明抛出多个异常，多个异常之间用逗号隔开。</strong></li>
<li><strong>使用throw关键字可以将一个异常抛出。通常如下情况我们会对外主动抛出异常:</strong><ul>
<li><strong>1.程序执行中发现一个满足语法要求，但是不满足业务逻辑要求的情况时,可以对外抛出异常告知不应当这样做。</strong></li>
<li><strong>2.程序确实出现了异常，但是该异常不应当在当前代码片段中被解决时,可以对外抛出给调用者解决(责任制问题)</strong></li>
</ul>
</li>
<li><strong>当我们调用一个含有throws声明异常抛出的方法时，编译器要求我们必须处理这个异常，否则编译不通过。</strong><ul>
<li><strong>两种处理方式：</strong><ul>
<li><strong>1.使用try-catch捕获并处理这个异常</strong></li>
<li><strong>2.在当前方法上继续使用throws将这个异常抛出,具体选择哪种解决方式取决于处理异常的责任问题</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="finally关键字"><a href="#finally关键字" class="headerlink" title="finally关键字"></a>finally关键字</h3><ul>
<li><strong>finally块是异常处理机制的最后一块，可以直接跟在try块之后或者最后一个catch之后。</strong></li>
<li><strong>finally块可以确保只要代码执行到try当中，无论try块 当中的代码是否抛出异常，finally块中的代码都必定执行，通常我们将释放的资源这样的操作放在finally中确保执行， 比如IO中关闭流的操作。</strong></li>
</ul>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul>
<li><strong>catch 不能独立于 try 存在。</strong></li>
<li><strong>在 try/catch 后面添加 finally 块并非强制性要求的。</strong></li>
<li><strong>try 代码后不能既没 catch 块也没 finally 块。</strong></li>
<li><strong>try, catch, finally 块之间不能添加任何代码。</strong></li>
</ul>
<h3 id="声明自定义异常"><a href="#声明自定义异常" class="headerlink" title="声明自定义异常"></a>声明自定义异常</h3><p><strong>在 Java 中你可以自定义异常。编写自己的异常类时需要记住下面的几点。</strong></p>
<ul>
<li><strong>所有异常都必须是 Throwable 的子类。</strong></li>
<li><strong>如果希望写一个检查性异常类，则需要继承 Exception 类。</strong></li>
<li><strong>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类。</strong></li>
</ul>
<h3 id="通用异常"><a href="#通用异常" class="headerlink" title="通用异常"></a>通用异常</h3><p><strong>在Java中定义了两种类型的异常和错误。</strong></p>
<ul>
<li><strong>JVM(Java虚拟机)异常：由 JVM 抛出的异常或错误。例如：NullPointerException 类，ArrayIndexOutOfBoundsException 类，ClassCastException 类。</strong></li>
<li><strong>程序级异常：由程序或者API程序抛出的异常。例如 IllegalArgumentException 类，IllegalStateException 类。</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/14/case-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/14/case-6/" itemprop="url">简易聊天室</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-14T20:55:18+08:00">
                2019-05-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Eclipse控制台简易聊天程序（仅限同一局域网）"><a href="#Eclipse控制台简易聊天程序（仅限同一局域网）" class="headerlink" title="Eclipse控制台简易聊天程序（仅限同一局域网）"></a>Eclipse控制台简易聊天程序（仅限同一局域网）</h2><h3 id="服务端程序"><a href="#服务端程序" class="headerlink" title="服务端程序"></a>服务端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays; </span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天室的服务端</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> soft01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * java.net.ServerSocket</span></span><br><span class="line"><span class="comment">	 * 运行在服务端的ServerSocket主要有两个作用</span></span><br><span class="line"><span class="comment">	 * 1：向系统申请服务端口，客户端就是通过这个端口与服务器建立连接的。</span></span><br><span class="line"><span class="comment">	 * 2：监听该端口，这样一旦一个客户端通过该端口尝试建立连接时，</span></span><br><span class="line"><span class="comment">	 * ServerSocket就会自动实例化一个Socket，</span></span><br><span class="line"><span class="comment">	 * 那么通过Socket就可以与客户端对等并进行数据交互了。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> ServerSocket server;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 该数组用于保存所有ClientHandler对应客户端的输出流，</span></span><br><span class="line"><span class="comment">	 * 以便所有ClientHandler都可以互访这些输出流来广播消息。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> PrintWriter[] allOut = &#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Server</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * 实例化ServerSocket的同时要向系统申请服务端口,</span></span><br><span class="line"><span class="comment">			 * 客户端就是通过这个端口与服务端建立连接的。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			System.out.println(<span class="string">"正在启动服务端..."</span>);</span><br><span class="line">			server = <span class="keyword">new</span> ServerSocket(<span class="number">8088</span>);</span><br><span class="line">			System.out.println(<span class="string">"服务端启动完毕！"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Socket accept()</span></span><br><span class="line"><span class="comment">			 * ServerSocketde的accept方法返回是一个阻塞方法，</span></span><br><span class="line"><span class="comment">			 * 调用后会一直等待，知道一个客户端建立连接为止，</span></span><br><span class="line"><span class="comment">			 * 此时该方法会返回一个Socket实例，通过这个Socket就</span></span><br><span class="line"><span class="comment">			 * 可以与刚连接上的客户端进行数据交互了。</span></span><br><span class="line"><span class="comment">			 * 多次调用accept可以等待不同客户端的连接</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line">			Socket socket = server.accept();</span><br><span class="line">			System.out.println(<span class="string">"一个客户端连接了!"</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//启动一个线程负责与客户端交互</span></span><br><span class="line">			ClientHandler handler = <span class="keyword">new</span> ClientHandler(socket);</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(handler);</span><br><span class="line">			t.start();</span><br><span class="line">			</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Server server = <span class="keyword">new</span> Server();</span><br><span class="line">			server.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该线程任务是负责与指定客户端进行交互操作</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">		<span class="keyword">private</span> Socket socket;</span><br><span class="line">		<span class="keyword">private</span> String host;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">ClientHandler</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">this</span>.socket = socket;</span><br><span class="line">			<span class="comment">//获取远端计算机IP地址信息的字符串格式</span></span><br><span class="line">			host = socket.getInetAddress().getHostAddress();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			PrintWriter pw = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 通过Socket获取输入流，可以读取到远端计算机发送过来的字节。</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				InputStream in = socket.getInputStream();</span><br><span class="line">				InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in,<span class="string">"UTF-8"</span>);</span><br><span class="line">				BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 通过socket获取输出流，用于给客户段发送消息。</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				OutputStream out = socket.getOutputStream();</span><br><span class="line">				OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(out,<span class="string">"UTF-8"</span>);</span><br><span class="line">				BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">				pw = <span class="keyword">new</span> PrintWriter(bw,<span class="keyword">true</span>);</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 将当前客户端对应的输出流存入allOut，</span></span><br><span class="line"><span class="comment">				 * 以便于其他ClientHandler可以将消息转发给这个客户端。</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">synchronized</span> (allOut) &#123;</span><br><span class="line">					<span class="comment">// 1.对allOut数组扩容</span></span><br><span class="line">					allOut = Arrays.copyOf(allOut, allOut.length + <span class="number">1</span>);</span><br><span class="line">					<span class="comment">// 2.将输出流存入数组最后一个位置</span></span><br><span class="line">					allOut[allOut.length - <span class="number">1</span>] = pw;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(host+<span class="string">"上线了！"</span>);</span><br><span class="line">				System.out.println(<span class="string">"当前在线人数为："</span>+allOut.length);</span><br><span class="line">				</span><br><span class="line">				String line = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">while</span>((line = br.readLine())!=<span class="keyword">null</span>) &#123;</span><br><span class="line">					System.out.println(host+<span class="string">"说："</span>+line);</span><br><span class="line">					<span class="comment">//将内容发送给客户端</span></span><br><span class="line">					<span class="keyword">synchronized</span> (allOut) &#123;</span><br><span class="line">						<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allOut.length; i++) &#123;</span><br><span class="line">							allOut[i].println(host + <span class="string">"说:"</span> + line);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 处理客户端断开连接的操作</span></span><br><span class="line">				<span class="keyword">synchronized</span> (allOut) &#123;</span><br><span class="line">					<span class="comment">// 1.将当前客户端输出流从allOut中删除</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; allOut.length; i++) &#123;</span><br><span class="line">						<span class="keyword">if</span> (allOut[i] == pw) &#123;</span><br><span class="line">							allOut[i] = allOut[allOut.length - <span class="number">1</span>];</span><br><span class="line">							allOut = Arrays.copyOf(allOut, allOut.length - <span class="number">1</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(host+<span class="string">"下线了！"</span>);</span><br><span class="line">				System.out.println(<span class="string">"当前在线人数为："</span>+allOut.length);</span><br><span class="line">				<span class="comment">// 2.关闭socket，释放资源</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					socket.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="客户端程序"><a href="#客户端程序" class="headerlink" title="客户端程序"></a>客户端程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天室的客户端</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> soft01</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * java.net.Socket 套接字 封装了TCP协议的通讯细节， </span></span><br><span class="line"><span class="comment">	 * 使得我们可以通过它来与远端计算机建立TCP连接， 并利用两个流的读写完成数据交换</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	<span class="keyword">private</span> Socket socket;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 构造方法，用来初始化客户端</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Socket实例化是需要传两个参数 </span></span><br><span class="line"><span class="comment">			 * 参数1：服务端IP地址 </span></span><br><span class="line"><span class="comment">			 * 参数2：服务端申请程序的端口 我们通过IP可以找到网络上的服务端计算机</span></span><br><span class="line"><span class="comment">			 * 通过端口可以连接到服务端计算机上运行的服务端应用程序。 </span></span><br><span class="line"><span class="comment">			 * 注意： 实例化Socket的过程就是连接的过程， 若服务端没有响应这里会抛出异常。</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			System.out.println(<span class="string">"正在连接服务端..."</span>);</span><br><span class="line">			<span class="comment">// localhost 本地服务</span></span><br><span class="line">			System.out.println(<span class="string">"请输入您要连接的IP："</span>);</span><br><span class="line">			socket = <span class="keyword">new</span> Socket(scan.nextLine(), <span class="number">8088</span>);</span><br><span class="line">			System.out.println(<span class="string">"成功连接服务端！"</span>);</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 客户端开始工作的方法</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// 用于读取服务端发送过来消息的线程</span></span><br><span class="line">			ServerHandler handler = <span class="keyword">new</span> ServerHandler();</span><br><span class="line">			Thread t = <span class="keyword">new</span> Thread(handler);</span><br><span class="line">			t.start();</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Socket提供的方法： OutputStream getOutputStream() </span></span><br><span class="line"><span class="comment">			 * 该方法获取的输入流是一个字节输出流</span></span><br><span class="line"><span class="comment">			 * 通过这个流写出的字节会通过网络发送到远端计算机上 (对于客户端这边而言，远端计算机指的就是服务端)</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			OutputStream out = socket.getOutputStream();</span><br><span class="line">			OutputStreamWriter osw = <span class="keyword">new</span> OutputStreamWriter(out, <span class="string">"UTF-8"</span>);</span><br><span class="line">			BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(osw);</span><br><span class="line">			PrintWriter pw = <span class="keyword">new</span> PrintWriter(bw, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">				String line = scan.nextLine();</span><br><span class="line">				pw.println(line);</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Client client = <span class="keyword">new</span> Client();</span><br><span class="line">		client.start();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 该线程负责循环读取服务发送过来的消息并输出到客户端的控制台上。</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@author</span> asus</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">// 通过socket获取输入流，读取服务端发送过来的内容。</span></span><br><span class="line">				InputStream in = socket.getInputStream();</span><br><span class="line">				InputStreamReader isr = <span class="keyword">new</span> InputStreamReader(in, <span class="string">"UTF-8"</span>);</span><br><span class="line">				BufferedReader br = <span class="keyword">new</span> BufferedReader(isr);</span><br><span class="line"></span><br><span class="line">				String line = <span class="keyword">null</span>;</span><br><span class="line">				<span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">					System.out.println(line);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/13/API-6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/13/API-6/" itemprop="url">API-6</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-13T18:08:29+08:00">
                2019-05-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="文本数据IO操作"><a href="#文本数据IO操作" class="headerlink" title="文本数据IO操作"></a>文本数据IO操作</h2><h3 id="Reader与Writer"><a href="#Reader与Writer" class="headerlink" title="Reader与Writer"></a>Reader与Writer</h3><ul>
<li><strong>Reader是字符输入流的父类,Writer是字符输出流的父类。</strong></li>
<li><strong>字符流是以字符（char）为单位读写数据的,一次处理一个unicode。</strong></li>
<li><strong>字符流的底层仍然是基本的字节流。</strong></li>
<li><p><strong>字符流封装了字符的编码解码算法。</strong></p>
</li>
<li><p><strong>Reader的常用方法：</strong></p>
<ul>
<li><strong>int read()：</strong><ul>
<li><strong>读取一个字节，返回的int值”低16”位有效。</strong></li>
</ul>
</li>
<li><strong>int read(char[] chs)：</strong><ul>
<li><strong>读取一个字符数组的length个字符并存入该数组，返回值为实际读取到的字符量。</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>Writer的常用方法：</strong></p>
<ul>
<li><strong>void write(int c)：</strong><ul>
<li><strong>写出一个字符，写出给定int值”低16”位表示的字符。</strong></li>
</ul>
</li>
<li><strong>void write(char[] chs)：</strong><ul>
<li><strong>将给定字符数组中所有字符写出。</strong></li>
</ul>
</li>
<li><strong>void write(String str)：</strong><ul>
<li><strong>将给定字符串写出。</strong></li>
</ul>
</li>
<li><strong>void write(char[] chs, int off, int len)：</strong><ul>
<li><strong>将给定的字符数组中从off处开始连续的冷个字符写出。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="转换流"><a href="#转换流" class="headerlink" title="转换流"></a>转换流</h3><ul>
<li><strong>InputStreamReader：字符输入流</strong><ul>
<li><strong>该流可以设置字符集，并按照指定的字符集从流中按照该编码将字节数据转换为字符并读取。</strong></li>
</ul>
</li>
<li><strong>OutputStreamWriter：字符输出流</strong><ul>
<li><strong>该流可以设置字符集，并按照指定的字符集将字符转换为对应字节都通过该流写出。</strong></li>
</ul>
</li>
<li><strong>InputStreamReader的构造方法允许我们设置字符集：</strong><ul>
<li><strong>InputStreamReader(InputStream in, String charsetName)：</strong><ul>
<li><strong>基于给定的字节输入流以及字符编码创建ISR。</strong></li>
</ul>
</li>
<li><strong>InputStreamReader(InputStream in)：</strong><ul>
<li><strong>本构造方法会根据系统默认字符集创建ISR。</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>OutputStreamWriter的构造方法：</strong><ul>
<li><strong>OutputStreamWrite(OutputStream out, String charsetName)：</strong><ul>
<li><strong>基于给定的字节输出流以及字符编码创建OSW。</strong></li>
</ul>
</li>
<li><strong>OutputStreamWrite(OutputStream out)：</strong><ul>
<li><strong>本构造方法会根据系统默认字符集创建OSW。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="PrintWriter"><a href="#PrintWriter" class="headerlink" title="PrintWriter"></a>PrintWriter</h3><ul>
<li><strong>创建PW对象</strong></li>
<li><p><strong>PrintWriter是具有自动行刷新的缓冲字符输出流。</strong></p>
<ul>
<li><strong>常用构造方法：</strong><ul>
<li><strong>PrintWriter(File file)</strong></li>
<li><strong>PrintWriter(String fileName)</strong></li>
<li><strong>PrintWriter(OutputStream out)</strong></li>
<li><strong>PrintWriter(OutputStream out, boolean autoFlush)</strong></li>
<li><strong>PrintWriter(Writer writer)</strong></li>
<li><strong>PrintWriter(Writer writer,  boolean autoFlush)</strong><ul>
<li><strong>其中参数为OutputSream与Writer的构造方法提供了可以传入boolean值的参数，该参数用于表示PrintWriter是否具有自动行刷新。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>print与println方法</strong></p>
</li>
<li><strong>PrintWriter提供了丰富的重载方法。其中println方法在输出目标数据后自动输出一个系统支持的换行符。若该流是具有自动行刷新的，那么每当通过println方法写出的内容都会被实际写出，而不是进入缓存。</strong></li>
<li><strong>常用方法：</strong><ul>
<li><strong>void print(int i ):打印整数</strong></li>
<li><strong>void print(char c):打印字符</strong></li>
<li><strong>void print(boolean b):打印boolean值</strong></li>
<li><strong>void print(char[] c):打印字符数组</strong></li>
<li><strong>void print(double d):打印double值</strong></li>
<li><strong>void print(int float):打印float值</strong></li>
<li><strong>void print(long l):打印long值</strong></li>
<li><strong>void print(String str):打印字符串</strong></li>
</ul>
</li>
</ul>
<h3 id="BufferedReader"><a href="#BufferedReader" class="headerlink" title="BufferedReader"></a>BufferedReader</h3><ul>
<li><strong>BufferedReader是缓冲字符输入流，其内部提供了缓冲区，可以提高读取效率。</strong></li>
<li><p><strong>常用方法：</strong></p>
<ul>
<li><strong>BufferedReader(Reader reader)</strong></li>
</ul>
</li>
<li><p><strong>BufferedReader提供了一个读取一行字符串的方法：</strong></p>
<ul>
<li><strong>String readLine()</strong></li>
<li><strong>读取一行字符串，返回值不含有该行末尾的换行符，如果返回值为null，则表示读取到了流的末尾，若是读取的文件，则表示文件读取到了末尾。</strong></li>
</ul>
</li>
</ul>
<h3 id="String、StringBuffer、StringBuilder区别"><a href="#String、StringBuffer、StringBuilder区别" class="headerlink" title="String、StringBuffer、StringBuilder区别"></a>String、StringBuffer、StringBuilder区别</h3><ul>
<li><strong>StringBuffer、StringBuilder和String一样，也用来代表字符串。String类是不可变类，任何对String的改变都 会引发新的String对象的生成；StringBuffer则是可变类，任何对它所指代的字符串的改变都不会产生新的对象。既然可变和不可变都有了，为何还有一个StringBuilder呢？相信初期的你，在进行append时，一般都会选择StringBuffer吧！</strong></li>
<li><strong>先说一下集合的故事，HashTable是线程安全的，很多方法都是synchronized方法，而HashMap不是线程安全的，但其在单线程程序中的性能比HashTable要高。StringBuffer和StringBuilder类的区别也是如此，他们的原理和操作基本相同，区别在于StringBufferd支持并发操作，线性安全的，适 合多线程中使用。StringBuilder不支持并发操作，线性不安全的，不适合多线程中使用。新引入的StringBuilder类不是线程安全的，但其在单线程中的性能比StringBuffer高。</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/11/API-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/11/API-5/" itemprop="url">API-5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-11T11:50:50+08:00">
                2019-05-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="基本IO操作"><a href="#基本IO操作" class="headerlink" title="基本IO操作"></a>基本IO操作</h2><h3 id="1-IO与OS"><a href="#1-IO与OS" class="headerlink" title="1.IO与OS"></a>1.IO与OS</h3><ul>
<li><strong>输入与输出：</strong><ul>
<li><strong>什么是输入：</strong><ul>
<li><strong>输入是一个从外界进入到程序的方向，通常我们需要”读取”外界的数据时，使用到输入。所以输入是用来读取数据的。</strong></li>
</ul>
</li>
<li><strong>什么是输出：</strong><ul>
<li><strong>输出是一个从程序发送到外界的方向，通常我们需要”写出”数据到外界时，使用到输出。所以输出是用来写出数据的。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="2-节点流与处理流"><a href="#2-节点流与处理流" class="headerlink" title="2.节点流与处理流"></a>2.节点流与处理流</h4><ul>
<li><strong>按照流是否直接与特定的地方(如磁盘，内存，设备等)相连，分为节点流和处理流两类。</strong><ul>
<li><strong>节点流(低级流)</strong><ul>
<li><strong>可以从或向一个特定的地方(节点)读写数据。</strong></li>
</ul>
</li>
<li><strong>处理流(高级流或过滤流)</strong><ul>
<li><strong>是对一个已存在的流的连接与封装，通过已封装的流的功能调用实现数据读写。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-IS和OS常用方法"><a href="#3-IS和OS常用方法" class="headerlink" title="3.IS和OS常用方法"></a>3.IS和OS常用方法</h4><ul>
<li><strong>InputStream是所有字节输入流的父类，其定义了基础的读取方法。</strong><ul>
<li><strong>方法：</strong><ul>
<li><strong>int read()：</strong><ul>
<li><strong>读取一个字节，以int形式返回，该int值的”低八位”有效，若返回值为-1则表示EOF。</strong></li>
</ul>
</li>
<li><strong>int read(byte[] d)：</strong><ul>
<li><strong>尝试最多读取给定数组length个字节并存入该数组，返回值为实际读取到的字节量。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>OutputStream是所有字节输出流的父类，其定义了基础写出方法。</strong><ul>
<li><strong>方法：</strong><ul>
<li><strong>void write(int d)：</strong><ul>
<li><strong>写出一个字节，写的是给定的int的”低八位”</strong></li>
</ul>
</li>
<li><strong>void write(byte[] d)：</strong><ul>
<li><strong>将给定的字节数组中的所有字节全部写出</strong></li>
</ul>
</li>
<li><strong>void write(byte[] d，int off，int len)：</strong><ul>
<li><strong>将指定 byte 数组中从偏移量 off 开始的 len 个字节写入此文件输出流。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-文件流"><a href="#4-文件流" class="headerlink" title="4.文件流"></a>4.文件流</h4><h5 id="创建FOS对象-重写模式"><a href="#创建FOS对象-重写模式" class="headerlink" title="创建FOS对象(重写模式)"></a>创建FOS对象(重写模式)</h5><ul>
<li><strong>FlieOutputStream是文件的字节输出流，我们使用该流可以以字节为单位将数据写入文件</strong><ul>
<li><strong>构造方法：</strong><ul>
<li><strong>FlieOutputStream(File file)：</strong><ul>
<li><strong>创建一个向指定Flie对象表示的文件中写出数据的输出流</strong></li>
</ul>
</li>
<li><strong>FlieOutputStream(String filename)：</strong><ul>
<li><strong>创建一个向具有指定名称的文件中写出数据的输出流</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>注意：</strong><ul>
<li><strong>若指定文件已经存在内容，使用Fos写入数据时，会将该文件中的数据覆盖。</strong></li>
</ul>
</li>
</ul>
<h5 id="创建FOS对象-追加模式"><a href="#创建FOS对象-追加模式" class="headerlink" title="创建FOS对象(追加模式)"></a>创建FOS对象(追加模式)</h5><ul>
<li><strong>若想在原文件后追加新数据则需要用以下构造方法创建FOS。</strong><ul>
<li><strong>构造方法：</strong><ul>
<li><strong>FlieOutputStream(File file，boolean append)：</strong></li>
<li><strong>FlieOutputStream(String filename,boolean append)：</strong><ul>
<li><strong>如第二个参数为true，通过该FOS写出的数据都是追加在文件原数据末尾写入的。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="创建FIS对象"><a href="#创建FIS对象" class="headerlink" title="创建FIS对象"></a>创建FIS对象</h5><ul>
<li><strong>FlieInputStream是文件的字节输入流，使用该流可以以字节为单位从文件中读取数据。</strong><ul>
<li><strong>构造方法：</strong><ul>
<li><strong>FlieInputStream(File file)：</strong><ul>
<li><strong>创建一个从指定File对象表示的文件中读取数据的文件输入流</strong></li>
</ul>
</li>
<li><strong>FlieInputStream(String filename)：</strong><ul>
<li><strong>创建用于读取给定文件系统中的路径名name所指定的文件的文件输入流</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="5-缓冲流"><a href="#5-缓冲流" class="headerlink" title="5.缓冲流"></a>5.缓冲流</h4><ul>
<li><strong>BufferedOutputStream缓冲输出流内部维护着一个缓冲区，每当我们向该流写数据时，会先将数据存入缓冲区，当缓冲区已满时，缓冲流会将数据一次性全部写出。</strong></li>
<li><p><strong>BOS的flush方法</strong></p>
<ul>
<li><strong>使用缓冲输出流可以提高写出效率，但是有一个问题，就是写出数据缺乏即时性。因为数据都存在缓冲区，当缓冲区满时，缓冲流才会将数据写出。所以我们在执行完写出操作后，无法及时查看写出数据。这时我们就需要用到缓冲流的flush方法。</strong></li>
<li><strong>void flush():</strong><ul>
<li><strong>强制将当前缓冲流已缓存的字节一次性写出</strong></li>
<li><strong>频繁调用flush会提高写出数据的频率，这会降低写出效率，但是会提高写出数据即时性。(按需求而定)</strong></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>BufferedInputStream是缓冲字节输入流,其内部维护着一个缓充区(字节数组)，该流在读取一个字节时，该流会尽可能多的一次性读取若干字节并存入缓冲区，然后逐一的将字节返回，直到缓冲区中的数据被全部读取完毕，会再次读取若干字节从而反复。这样就减少了读取的次数，从而提高了读取效率。</strong></p>
</li>
<li><strong>BIS是一个处理流，该流为我们提供了缓冲功能。</strong></li>
</ul>
<h4 id="6-对象流"><a href="#6-对象流" class="headerlink" title="6.对象流"></a>6.对象流</h4><ul>
<li><strong>对象序列化</strong><ul>
<li><strong>对象是存在内存中的。有时我们需要将对象保存到硬盘上，又有时我们需要经对象传到另一台计算机上，等等这样的操作，而这个过程就称作对象序列化。相反，我们有这样的一个字节序列需要将其转换为对应的对象，这个过程称为对象的反序列化。</strong></li>
</ul>
</li>
<li><strong>ObjectPutputStream是用来对对象进行序列化的输出流。</strong><ul>
<li><strong>实现对象序列化方法：</strong><ul>
<li><strong>void writeObject(Object o)：</strong><ul>
<li><strong>可以将给定的对象转换为一个字节序列后写出。</strong> </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>ObjectInputStream是用来对对象进行反序列化的输入流。</strong><ul>
<li><strong>实现对象反序列化方法：</strong><ul>
<li><strong>Object readObject()：</strong><ul>
<li><strong>可以从流中读取字节并转换为对应的对象。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="7-Serializable接口"><a href="#7-Serializable接口" class="headerlink" title="7.Serializable接口"></a>7.Serializable接口</h4><ul>
<li><strong>用于启动对象的序列化功能，可以强制让指定类具备序列化功能，该接口中没有成员，这是一个标记接口。这个标记接口用于给序列化类提供UID。这个uid是依据类中的成员的数字签名进行运行获取的。如果不需要自动获取一个uid，可以在类中，手动指定一个名称为serialVersionUID id号。依据编译器的不同，或者对信息的高度敏感性。最好每一个序列化的类都进行手动显示的UID的指定。</strong></li>
</ul>
<h4 id="8-transient关键字"><a href="#8-transient关键字" class="headerlink" title="8.transient关键字"></a>8.transient关键字</h4><ol>
<li><strong>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。</strong></li>
<li><strong>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</strong></li>
<li><strong>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。也可以认为在将持久化的对象反序列化后，被transient修饰的变量将按照普通类成员变量一样被初始化。</strong></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/09/case-5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/09/case-5/" itemprop="url">练习案例-5</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-09T19:54:31+08:00">
                2019-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="猜字符游戏"><a href="#猜字符游戏" class="headerlink" title="猜字符游戏"></a>猜字符游戏</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuessingGame</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 表示玩家猜测的次数</span></span><br><span class="line">		<span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 用于保存判断的结果 </span></span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">		Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"GuessingGame&gt;欢迎尝试猜字母游戏！"</span>);</span><br><span class="line">		<span class="comment">// 表示猜测的字符串</span></span><br><span class="line">		<span class="keyword">char</span>[] chs = generate();</span><br><span class="line">		System.out.println(chs); <span class="comment">//作弊</span></span><br><span class="line">		System.out.println(<span class="string">"GuessingGame&gt;游戏开始，请输入你所猜的5个字母序列：（exit——退出）"</span>);</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			String inputStr = scanner.next().toUpperCase();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"EXIT"</span>.equals(inputStr)) &#123;</span><br><span class="line">				System.out.println(<span class="string">"GuessingGame&gt;谢谢你的尝试，再见！"</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">char</span>[] input = inputStr.toCharArray();</span><br><span class="line">			result = check(chs, input);</span><br><span class="line">			<span class="keyword">if</span> (result[<span class="number">0</span>] == chs.length) &#123;<span class="comment">// 完全猜对的情况</span></span><br><span class="line">				<span class="keyword">int</span> score = <span class="number">100</span> * chs.length - count * <span class="number">10</span>;</span><br><span class="line">				System.out.println(<span class="string">"GuessingGame&gt;恭喜你猜对了！你的得分是："</span> + score);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				count++;</span><br><span class="line">				System.out.println(<span class="string">"GuessingGame&gt;你猜对"</span> + result[<span class="number">1</span>] + <span class="string">"个字符，其中"</span></span><br><span class="line">					+ result[<span class="number">0</span>] + <span class="string">"个字符的位置正确！（总次数="</span> + count + <span class="string">"，exit——退出）"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 随机生成需要猜测的字母序列</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 存储随机字符的数组</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">char</span>[] generate() &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">char</span>[] letters = &#123; <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>, <span class="string">'G'</span>, <span class="string">'H'</span>, <span class="string">'I'</span>, <span class="string">'J'</span>,</span><br><span class="line">				<span class="string">'K'</span>, <span class="string">'L'</span>, <span class="string">'M'</span>, <span class="string">'N'</span>, <span class="string">'O'</span>, <span class="string">'P'</span>, <span class="string">'Q'</span>, <span class="string">'R'</span>, <span class="string">'S'</span>, <span class="string">'T'</span>, <span class="string">'U'</span>, <span class="string">'V'</span>,</span><br><span class="line">				<span class="string">'W'</span>, <span class="string">'X'</span>, <span class="string">'Y'</span>, <span class="string">'Z'</span> &#125;;</span><br><span class="line">		<span class="keyword">boolean</span>[] flags = <span class="keyword">new</span> <span class="keyword">boolean</span>[letters.length];</span><br><span class="line">		<span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">5</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chs.length; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> index;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				index = (<span class="keyword">int</span>) (Math.random() * (letters.length));</span><br><span class="line">			&#125; <span class="keyword">while</span> (flags[index]);<span class="comment">// 判断生成的字符是否重复</span></span><br><span class="line">			chs[i] = letters[index];</span><br><span class="line">			flags[index] = <span class="keyword">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> chs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 比较玩家输入的字母序列和程序所生成的字母序列，逐一比较字符及其位置，并记载比较结果</span></span><br><span class="line"><span class="comment">	 * </span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> chs</span></span><br><span class="line"><span class="comment">	 *            程序生成的字符序列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">	 *            玩家输入的字符序列</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 存储比较的结果。返回值int数组 的长度为2，其中，索引为0的位置</span></span><br><span class="line"><span class="comment">	 *         用于存放完全猜对的字母个数(字符和位置均正确)，索引为1的位置用于存放猜对的字母个数(字符正确，但是位置不正确)。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] check(<span class="keyword">char</span>[] chs, <span class="keyword">char</span>[] input) &#123;</span><br><span class="line">		<span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; chs.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (input[i] == chs[j]) &#123;<span class="comment">// 判断字符是否正确</span></span><br><span class="line">					result[<span class="number">1</span>]++;</span><br><span class="line">					<span class="keyword">if</span> (i == j) &#123;<span class="comment">// 判断位置是否正确</span></span><br><span class="line">						result[<span class="number">0</span>]++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/08/case-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/08/case-4/" itemprop="url">练习案例-4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-08T19:59:45+08:00">
                2019-05-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JAVA-数列求和"><a href="#JAVA-数列求和" class="headerlink" title="JAVA 数列求和"></a>JAVA 数列求和</h2><p><strong>1. 有数列为：9，99，999，…，9999999999。要求使用程序计算此数列的和，并在控制台输出结果。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">long</span> num = <span class="number">9</span>;</span><br><span class="line">		<span class="keyword">long</span> result = num;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10</span>; i++) &#123;</span><br><span class="line">			num = num * <span class="number">10</span> + <span class="number">9</span>;</span><br><span class="line">			result = result+num;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"num="</span> + result);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2. 另有数列：1+1/2+1/3…+1/n（n&gt;=2）。要求使用交互的方式计算此数列的和：用户在控制台录入需要计算的整数 n 的值，程序计算此数列的和，并在控制台输出结果。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入一个整数："</span>);</span><br><span class="line">		<span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">		<span class="keyword">if</span> (n &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">double</span> result1 = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">				result1 += <span class="number">1.0</span> / i ;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">"result="</span> + result1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组案例"><a href="#数组案例" class="headerlink" title="数组案例"></a>数组案例</h2><h4 id="1-查询数组最小值，并将其放在第一位"><a href="#1-查询数组最小值，并将其放在第一位" class="headerlink" title="1. 查询数组最小值，并将其放在第一位"></a>1. 查询数组最小值，并将其放在第一位</h4><p><strong>创建程序，实现查询数组中最小值的功能，并将最小值放入数组的第一位。需求为：创建一个长度为 10 的数组，数组内放置 10 个 0 到 99 之间（包含0，包含99）的随机整数作为数组元素，要求查询出数组中的最小值，并打印显示在界面上。然后，将查询到的数组最小值记载为数组的第一个元素，并打印赋值后的数组内容。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;	</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>) (Math.random() * <span class="number">100</span>);</span><br><span class="line">			System.out.println(arr[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">			<span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">				min = arr[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"最小值为:"</span> + min);</span><br><span class="line">		<span class="keyword">int</span>[] as = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">		System.arraycopy(arr, <span class="number">0</span>, as, <span class="number">1</span>, arr.length);</span><br><span class="line">		as[<span class="number">0</span>] = min;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; i++) &#123;</span><br><span class="line">			System.out.println(as[i]);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-随机生成数组"><a href="#2-随机生成数组" class="headerlink" title="2. 随机生成数组"></a>2. 随机生成数组</h4><p><strong>封装一个方法generateArray，该方法实现生成指定长度的int数组，该数组的元素为0到指定范围内的随机数，并将该数组返回。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入指定长度："</span>);</span><br><span class="line">		<span class="keyword">int</span> m = scan.nextInt();</span><br><span class="line">		System.out.println(<span class="string">"请输入指定范围："</span>);</span><br><span class="line">		<span class="keyword">int</span> n = scan.nextInt();</span><br><span class="line">		<span class="keyword">int</span>[] arr = generateArray(m,n);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			System.out.print(arr[i]+<span class="string">" "</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] generateArray(<span class="keyword">int</span> len,<span class="keyword">int</span> max)&#123;</span><br><span class="line">		<span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++) &#123;</span><br><span class="line">			arr[i] = (<span class="keyword">int</span>)(Math.random()*max);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/07/case-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/07/case-3/" itemprop="url">练习案例-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-07T20:33:40+08:00">
                2019-05-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-编写个人所得税计算程序"><a href="#1-编写个人所得税计算程序" class="headerlink" title="1.编写个人所得税计算程序"></a><strong>1.编写个人所得税计算程序</strong></h3><p><strong>个人所得税是国家对本国公民、居住在本国境内的个人的所得和境外个人来源于本国的所得征收的一种所得税。目前，北京地区的个人所得税的计算公式为：应纳税额＝（工资薪金所得－扣除数）×适用税率－速算扣除数。其中，扣除数为3500元，适用税率以及速算扣除数如下表所示。</strong></p>
<table>
<thead>
<tr>
<th>全月应纳税所得额</th>
<th>税率</th>
<th>速算扣除数(元)</th>
</tr>
</thead>
<tbody>
<tr>
<td>全月应纳税额不超过1500元</td>
<td>3%</td>
<td>0</td>
</tr>
<tr>
<td>全月应纳税额超过1500元至4500元</td>
<td>10%</td>
<td>105</td>
</tr>
<tr>
<td>全月应纳税额超过4500元至9000元</td>
<td>20%</td>
<td>555</td>
</tr>
<tr>
<td>全月应纳税额超过9000元至35000元</td>
<td>25%</td>
<td>1005</td>
</tr>
<tr>
<td>全月应纳税额超过35000元至55000元</td>
<td>30%</td>
<td>2755</td>
</tr>
<tr>
<td>全月应纳税额超过55000元至80000元</td>
<td>35%</td>
<td>5505</td>
</tr>
<tr>
<td>全月应纳税额超过80000元</td>
<td>45%</td>
<td>13505</td>
</tr>
</tbody>
</table>
<p><strong>上表中的全月应纳税所得额=工资薪金所得－扣除数。</strong><br><strong>本案例要求计算个人所得税的缴纳额度：用户从控制台输入税前工资的金额，程序计算所需要交纳的个人所得税的金额，并将计算结果输出到控制台。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scan = new Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入您的工资税前金额(￥):"</span>);</span><br><span class="line">		double wage = scan.nextDouble();</span><br><span class="line">		wage -= 3500;</span><br><span class="line">		double num = 0;</span><br><span class="line">		<span class="keyword">if</span> (wage &lt;= 0) &#123;</span><br><span class="line">			num = 0;// 不纳税</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt;= 1500) &#123;</span><br><span class="line">			num = wage * 0.03;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt;= 4500) &#123;</span><br><span class="line">			num = wage * 0.1 - 105;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt;= 9000) &#123;</span><br><span class="line">			num = wage * 0.2 - 555;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt;= 35000) &#123;</span><br><span class="line">			num = wage * 0.25 - 1005;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt;= 55000) &#123;</span><br><span class="line">			num = wage * 0.3 - 2755;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &lt;= 80000) &#123;</span><br><span class="line">			num = wage * 0.35 - 5505;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wage &gt;= 80000) &#123;</span><br><span class="line">			num = wage * 0.45 - 13505;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"您应该缴纳的个人所得税是(￥):"</span> + num);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-输入年份和月份，输出该月的天数（使用switch-case）"><a href="#2-输入年份和月份，输出该月的天数（使用switch-case）" class="headerlink" title="2.输入年份和月份，输出该月的天数（使用switch-case）"></a>2.输入年份和月份，输出该月的天数（使用switch-case）</h3><p><strong>一年有 12 个月，而每个月的天数是不一样的。其中，有7个月为 31 天，称为大月，分别为1、3、5、7、8、10、12月；有 4个月为 30 天，称为小月，分别为4、6、9、11月；还有二月比较特殊，平年的二月只有28天，而闰年的二月有 29 天。</strong><br><strong>本案例需要使用交互的方式计算某年某月的天数：由用户在控制台输入年份和月份值，程序计算该年该月的天数，并将结果输出在控制台。</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Scanner scan = new Scanner(System.in);</span><br><span class="line">		System.out.println(<span class="string">"请输入年份："</span>);</span><br><span class="line">		int year = scan.nextInt();</span><br><span class="line">		System.out.println(<span class="string">"请输入月份："</span>);</span><br><span class="line">		int month = scan.nextInt();</span><br><span class="line">		int day = 0;</span><br><span class="line">		switch (month) &#123;</span><br><span class="line">		<span class="keyword">case</span> 1:</span><br><span class="line">		<span class="keyword">case</span> 3:</span><br><span class="line">		<span class="keyword">case</span> 5:</span><br><span class="line">		<span class="keyword">case</span> 7:</span><br><span class="line">		<span class="keyword">case</span> 8:</span><br><span class="line">		<span class="keyword">case</span> 10:</span><br><span class="line">		<span class="keyword">case</span> 12:</span><br><span class="line">			day = 31;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">case</span> 4:</span><br><span class="line">		<span class="keyword">case</span> 6:</span><br><span class="line">		<span class="keyword">case</span> 9:</span><br><span class="line">		<span class="keyword">case</span> 11:</span><br><span class="line">			day = 30;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		<span class="keyword">case</span> 2:</span><br><span class="line">			<span class="keyword">if</span> (year % 4 == 0 &amp;&amp; year % 100 != 0 || year % 400 == 0) &#123;</span><br><span class="line">				System.out.println(year + <span class="string">"是闰年"</span>);</span><br><span class="line">				day = 29;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				System.out.println(year + <span class="string">"是平年"</span>);</span><br><span class="line">				day = 28;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(year + <span class="string">"年"</span> + month + <span class="string">"月"</span> + <span class="string">"有"</span> + day + <span class="string">"天"</span>);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/06/API-4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/06/API-4/" itemprop="url">API-4</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-06T19:06:40+08:00">
                2019-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><h4 id="对文件的操作"><a href="#对文件的操作" class="headerlink" title="对文件的操作"></a>对文件的操作</h4><p><strong>获取某个目录下所有的子项目</strong></p>
<ul>
<li><strong>listFiles()</strong> <pre><code>返回一个抽象路径名数组，这些路径名表示此抽象路径名表示的目录中的文件。
</code></pre></li>
<li><strong>listFiles(FileFilter filter)</strong> <pre><code>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录。
</code></pre></li>
<li><strong>listFiles(FilenameFilter filter)</strong> <pre><code>返回抽象路径名数组，这些路径名表示此抽象路径名表示的目录中满足指定过滤器的文件和目录
</code></pre></li>
<li><strong>listFiles(FileFilter filter):File[]</strong><ul>
<li><strong>获取指定目录下所有满足条件的File对象</strong></li>
<li><strong>FileFilter:是个接口，其中有抽象方法accept，此方法用于实现过滤，将过滤条件写在本方法体中。</strong><h3 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h3><strong>在一个方法体内部调用方法本身</strong><h3 id="文件操作-RandomAccessFile"><a href="#文件操作-RandomAccessFile" class="headerlink" title="文件操作 - RandomAccessFile"></a>文件操作 - RandomAccessFile</h3></li>
</ul>
</li>
<li><strong>File的实例可以对文件进行以上3种访问操作，但是不可以访问文件中的数据。</strong></li>
<li><strong>RandomAccessFile实例可以实现对文件数据的访问（读写操作）</strong></li>
<li><strong>构造方法：</strong><ul>
<li><strong>RandomAccessFile(File/String dest,String mode)</strong><br>  <strong>mode：访问模式</strong><br>  <strong>常用的2个访问模式：</strong><pre><code>&quot;r&quot; :只读
&quot;rw&quot;：读写
</code></pre></li>
</ul>
</li>
<li><strong>方法：</strong><ul>
<li><strong>写数据：</strong><ul>
<li><strong>write(int n):向文件中写入一个字节</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>- 作为了解：
    - 计算机底层存储的是二进制数据，即保存的是0和1，一个二进制数占用的内存大小即为1位，一个字节占用8位
        - byte  1字节 8位的
        - int   4字节  32位
        - long  8字节  64位 
处理器：32位的：处理一个数据时一次占用32位
    byte占用低8位
    00000000 00000000 00000000 01100000
                                低八位
    处理器处理int值和处理byte值效率是一样的，
    因为都是占用32位处理的
- 读数据
    - read():int
        - 读取一个字节数据，以int形式返回
        - 若读取到文件末尾，返回-1

按照单字节方式复制效率低，为了提高效率，我们可以采取每次复制一个字节数组的字节量，从而减少复制的次数，提高效率
</code></pre><ul>
<li><strong>按照字节数组读取数据</strong><ul>
<li><strong>read(byte[] bys):int</strong><ul>
<li><strong>将从文件中读取到的字节数据存入此数组中，int表示实际读取到的字节长度</strong></li>
</ul>
</li>
<li><strong>write(byte[]):</strong><ul>
<li><strong>向文件中写入一个字节数组</strong></li>
</ul>
</li>
<li><strong>write(byte[] bys，int index,int len)</strong><ul>
<li><strong>向目标文件中写入bys中从index开始的连续len个字节</strong></li>
</ul>
</li>
<li><strong>close（）方法</strong><ul>
<li><strong>RandomAccessFile对文件访问的操作全部结束后，调用close（）方法</strong><br><strong>来释放与其关联的所有系统资源</strong><h3 id="文件指针操作"><a href="#文件指针操作" class="headerlink" title="文件指针操作"></a>文件指针操作</h3><strong>RandomAccessFile的读写操作都是基于指针的，也就是说总是在指针当前所指向的位置进行读写操作</strong></li>
</ul>
</li>
</ul>
</li>
<li><strong>getFilePointer()</strong><ul>
<li><strong>该方法用于获取当前RandomAccessFile指针位置</strong></li>
</ul>
</li>
<li><strong>seek()</strong><ul>
<li><strong>该方法用于移动当前RandomAccessFlie的指针位置</strong></li>
</ul>
</li>
<li><strong>skipBytes()</strong><ul>
<li><strong>尝试跳过输入的 n 个字节以丢弃跳过的字节。</strong></li>
<li><strong>此方法可能跳过一些较少数量的字节（可能包括零）。这可能由任意数量的条件引起；在跳过 n 个字节之前已到达文件的末尾只是其中的一种可能。</strong></li>
<li><strong>此方法从不抛出 EOFException。返回跳过的实际字节数。如果 n 为负数，则不跳过任何字节。</strong></li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/05/API-3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Alone5">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wt Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/05/API-3/" itemprop="url">API-3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-05T19:46:40+08:00">
                2019-05-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p><strong>Object是java提供的一个类，是所有类的父类。</strong></p>
<ul>
<li><strong>1) toString():</strong><ul>
<li><strong>返回该对象的字符串表示</strong> </li>
<li><strong>类名@散列码（整数）</strong> </li>
<li><strong>当输出一个对象的引用时，会自动去调用所属类的toString()</strong></li>
<li><strong>java中建议：子类对toString()最好都进行重写，使其更具有实际意义</strong></li>
</ul>
</li>
<li><strong>2) equals()</strong><ul>
<li><strong>在Object类中作用等同于 == 的作用</strong></li>
<li><strong>java中对此方法给出建议：建议在子类中重写此方法，使其更具有实际意义</strong></li>
</ul>
</li>
</ul>
<h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h4 id="什么是包装类"><a href="#什么是包装类" class="headerlink" title="什么是包装类"></a>什么是包装类</h4><p><strong>1）java中对8种基本类型都提供了对应的包装类，用于将数据包装成对象</strong><br><strong>2）java是面向对象的语言，基本数据类型不是对象，所以提供了包装类用于<br>将基本类型数据包装成对象使用</strong><br><strong>8种基本类型对应的包装类：</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">byte  --&gt; Byte</span><br><span class="line">short --&gt; Short</span><br><span class="line">int  --&gt; Integer</span><br><span class="line">long  --&gt; Long</span><br><span class="line"><span class="built_in">float</span> --&gt; Float</span><br><span class="line">double --&gt; Double</span><br><span class="line">char   --&gt; Character</span><br><span class="line">boolean --&gt; Boolean</span><br></pre></td></tr></table></figure></p>
<ul>
<li><strong>了解：</strong><br>  <strong>基本类型和包装类型，若用于计算，基本类型计算的比包装类型计算更快</strong></li>
</ul>
<p><strong>8种包装类中实现的功能都类似，列举其一进行讲解：</strong></p>
<h3 id="Integer"><a href="#Integer" class="headerlink" title="Integer"></a>Integer</h3><ul>
<li><strong>valueOf(int):Integer</strong><ul>
<li><strong>得到int对应的包装类型对象</strong></li>
</ul>
</li>
<li><strong>intValue():</strong><ul>
<li><strong>从包装类型–&gt;基本类型</strong></li>
</ul>
</li>
<li><strong>parseInt(String):int</strong><ul>
<li><strong>String–&gt;int</strong></li>
<li><strong>前提：String表示的值一定是可以转换成int类型才可以</strong><h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3></li>
</ul>
</li>
</ul>
<ol>
<li><strong>装箱：将基本类型数据包装成包装类型</strong><ol>
<li><strong>int–&gt;Integer</strong></li>
<li><strong>通过valueOf(int)完成的</strong></li>
</ol>
</li>
<li><strong>拆箱：将包装类型数据拆成基本类型</strong><ol>
<li><strong>Integer–&gt;int</strong></li>
<li><strong>通过intValue()实现的</strong><h4 id="自动装箱，自动拆箱"><a href="#自动装箱，自动拆箱" class="headerlink" title="自动装箱，自动拆箱"></a>自动装箱，自动拆箱</h4></li>
</ol>
</li>
</ol>
<ul>
<li><strong>自动装箱，自动拆箱是java从JDK1.5开始提供的功能，是编译器实现的</strong><br>  <strong>如何实现：编译过程中，编译器将Integer i = 3;替换成了</strong><pre><code>Integer i = Integer.valueOf(3);
</code></pre></li>
</ul>
<h3 id="文件操作-File"><a href="#文件操作-File" class="headerlink" title="文件操作-File"></a>文件操作-File</h3><ul>
<li><strong>File：实现对文件的操作</strong></li>
<li><strong>通过File对象可以实现对文件/目录的以下操作</strong><ol>
<li><strong>创建，删除文件/目录</strong></li>
<li><strong>获取文件/目录的属性信息</strong></li>
<li><strong>获取指定目录下的所有子项目</strong></li>
</ol>
</li>
<li><strong>构造方法：</strong><ul>
<li><strong>File(String path)</strong></li>
<li><strong>File(File parent,String child)</strong></li>
<li><strong>File(String parent,String child)</strong></li>
</ul>
</li>
<li><strong>方法：</strong><ol>
<li><strong>创建文件</strong><ol>
<li><strong>creatNewFile()</strong></li>
</ol>
</li>
<li><strong>创建目录</strong><ol>
<li><strong>mkdir():创建一个目录</strong></li>
<li><strong>mkdirs()：创建多级目录</strong></li>
</ol>
</li>
<li><strong>delete()：</strong><ol>
<li><strong>删除文件/目录，注意，若删除的目录下还有子文件/目录，删除失败</strong></li>
</ol>
</li>
<li><strong>getName():String</strong><ol>
<li><strong>获取文件名称</strong></li>
</ol>
</li>
<li><strong>length():long</strong><ol>
<li><strong>获取文件内容的大小（字节）</strong></li>
<li><strong>对文件进行读写操作的基本单位是字节</strong></li>
</ol>
</li>
<li><strong>exists():boolean</strong><ol>
<li><strong>判断文件是否存在</strong></li>
<li><strong>通常和其他方法一起使用</strong><ol>
<li><strong>eg:创建文件</strong><ol>
<li><strong>如果不存在，创建</strong></li>
<li><strong>否则不创建，给出提示</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><strong>isFile():boolean</strong><ol>
<li><strong>判断File对象指向的是否是文件</strong> </li>
</ol>
</li>
<li><strong>isDirectory():boolean</strong><ol>
<li><strong>判断File对象指向的是否是目录</strong></li>
</ol>
</li>
</ol>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Alone5</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">70</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Alone5</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
